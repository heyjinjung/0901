"""Authentication API Router"""
import logging
from datetime import datetime
from typing import Optional
from fastapi import APIRouter, Depends, HTTPException, status, Request
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel
from sqlalchemy.orm import Session
from ..database import get_db
from ..schemas.auth import UserCreate, UserLogin, AdminLogin, UserResponse, Token
from ..services.auth_service import AuthService, security
from ..models.auth_models import User, InviteCode
from ..config_simple import settings

# Logger setup
logger = logging.getLogger(__name__)

# Auth service instance
auth_service = AuthService()

# OAuth2 schema
oauth2_scheme = HTTPBearer()

# Configuration values
JWT_EXPIRE_MINUTES = settings.jwt_expire_minutes
INITIAL_CYBER_TOKENS = getattr(settings, 'initial_cyber_tokens', 200)

router = APIRouter(prefix="/api/auth", tags=["Authentication"])

@router.post("/signup", response_model=Token)
async def signup(
    data: UserCreate,
    db = Depends(get_db)
):
    """User registration (5 required fields: site_id, nickname, phone_number, invite_code, password)"""
    try:
        logger.info(f"Registration attempt: site_id={data.site_id}, nickname={data.nickname}")
        
        # 비밀번호 검증 (4글자 이상)
        if len(data.password) < 4:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="비밀번호는 4글자 이상이어야 합니다"
            )
        
        # Create user through AuthService
        user = auth_service.create_user(db, data)
        
        # Generate token - 수정: 딕셔너리로 전달
        access_token = auth_service.create_access_token({
            "sub": user.site_id,
            "user_id": user.id,
            "is_admin": user.is_admin
        })
        
        # Create user response data
        user_response = UserResponse(
            id=user.id,
            site_id=user.site_id,
            nickname=user.nickname,
            phone_number=user.phone_number,
            cyber_token_balance=user.cyber_token_balance,
            created_at=user.created_at,
            last_login=user.last_login or user.created_at,  # last_login이 None이면 created_at 사용
            is_admin=user.is_admin,
            is_active=user.is_active
        )
        
        logger.info(f"Registration successful: user_id={user.id}")
        
        return Token(
            access_token=access_token,
            token_type="bearer",
            user=user_response
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Signup error: {e}")
        raise HTTPException(status_code=500, detail="Registration processing error occurred")

# 로그인 라우터 수정 - 올바른 응답 포맷으로 변경
@router.post("/login", response_model=Token)
async def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    """사용자 로그인"""
    try:
        # 사용자 인증
        user = auth_service.authenticate_user(db, form_data.username, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="아이디 또는 비밀번호가 잘못되었습니다",
                headers={"WWW-Authenticate": "Bearer"},
            )
            
        # JWT 토큰 생성 - 수정: 딕셔너리로 전달
        access_token = auth_service.create_access_token({
            "sub": user.site_id,
            "user_id": user.id,
            "is_admin": user.is_admin
        })
        
        # 마지막 로그인 시간 업데이트
        user.last_login = datetime.utcnow()
        db.commit()
        
        # Create user response
        user_response = UserResponse(
            id=user.id,
            site_id=user.site_id,
            nickname=user.nickname,
            phone_number=user.phone_number,
            cyber_token_balance=user.cyber_token_balance,
            created_at=user.created_at,
            last_login=user.last_login,
            is_admin=user.is_admin,
            is_active=user.is_active
        )
        
        return Token(
            access_token=access_token,
            token_type="bearer",
            user=user_response
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Login error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Login processing error occurred"
        )

@router.post("/admin/login", response_model=Token)
async def admin_login(
    form_data: AdminLogin,
    db = Depends(get_db)
):
    """Admin login"""
    try:
        logger.info(f"Admin login attempt: site_id={form_data.site_id}")
        
        # Admin authentication through AuthService
        user = auth_service.authenticate_admin(db, form_data.site_id, form_data.password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid admin credentials",
                headers={"WWW-Authenticate": "Bearer"},
            )
            
        # Generate access token - 수정: 딕셔너리로 전달
        access_token = auth_service.create_access_token({
            "sub": user.site_id,
            "user_id": user.id,
            "is_admin": user.is_admin
        })
        
        # Update last login time
        user.last_login = datetime.utcnow()
        db.commit()
        
        # Create user response
        user_response = UserResponse(
            id=user.id,
            site_id=user.site_id,
            nickname=user.nickname,
            phone_number=user.phone_number,
            cyber_token_balance=user.cyber_token_balance,
            created_at=user.created_at,
            last_login=user.last_login,
            is_admin=user.is_admin,
            is_active=user.is_active
        )
        
        logger.info(f"Admin login successful: user_id={user.id}")
        
        return Token(
            access_token=access_token,
            token_type="bearer",
            user=user_response
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Admin login error: {e}")
        raise HTTPException(status_code=500, detail="Admin login processing error occurred")
