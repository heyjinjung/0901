from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, HTTPBearer
from jose import jwt, JWTError
from sqlalchemy.orm import Session
from .models.auth_models import User
from .database import get_db
from .config_simple import settings

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/auth/login")
security = HTTPBearer()

def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)) -> User:
    """Get current authenticated user."""
    import logging
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.DEBUG)
    
    # 콘솔 로그 핸들러 설정
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    
    logger.debug(f"[AUTH DEBUG] Token received: {token[:20]}...")
    logger.debug(f"[AUTH DEBUG] Using secret key: {settings.jwt_secret_key[:5]}...")
    
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        logger.debug(f"[AUTH DEBUG] Attempting to decode token with algorithm: {settings.jwt_algorithm}")
        payload = jwt.decode(token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm])
        logger.debug(f"[AUTH DEBUG] Token decoded successfully. Payload: {payload}")
        
        # user_id 또는 sub 필드에서 사용자 ID 추출 시도
        user_id = payload.get("user_id")
        
        # user_id가 없으면 sub 필드 사용 시도 (대체 방법)
        if user_id is None:
            site_id = payload.get("sub")
            logger.debug(f"[AUTH DEBUG] No user_id found, trying to use sub field: {site_id}")
            
            if site_id is not None:
                # site_id로 사용자 조회 시도
                try:
                    user = db.query(User).filter(User.site_id == site_id).first()
                    if user:
                        user_id = user.id
                        logger.debug(f"[AUTH DEBUG] Found user_id {user_id} from site_id {site_id}")
                    else:
                        logger.error(f"[AUTH DEBUG] No user found with site_id: {site_id}")
                except Exception as e:
                    logger.error(f"[AUTH DEBUG] Error finding user by site_id: {str(e)}")
            
        logger.debug(f"[AUTH DEBUG] Final user_id to use: {user_id}")
        
        if user_id is None:
            logger.error("[AUTH DEBUG] Could not determine user_id from token payload")
            raise credentials_exception
    except JWTError as e:
        logger.error(f"[AUTH DEBUG] JWT Error: {str(e)}")
        raise credentials_exception
    except ValueError as e:
        logger.error(f"[AUTH DEBUG] Value Error: {str(e)}")
        raise credentials_exception
    except TypeError as e:
        logger.error(f"[AUTH DEBUG] Type Error: {str(e)}")
        raise credentials_exception
    except Exception as e:
        logger.error(f"[AUTH DEBUG] Unexpected error: {str(e)}")
        raise credentials_exception
        
    try:
        logger.debug(f"[AUTH DEBUG] Querying database for user with id: {user_id}")
        user = db.query(User).filter(User.id == user_id).first()
        
        if user is None:
            logger.error(f"[AUTH DEBUG] No user found with id: {user_id}")
            raise credentials_exception
            
        # 디버그: 사용자 객체의 속성 출력
        logger.debug(f"[AUTH DEBUG] User found: id={user.id}, site_id={user.site_id}")
        
        # 디버그: security_events 관계 테스트
        try:
            if hasattr(user, 'security_events'):
                logger.debug(f"[AUTH DEBUG] User has security_events attribute")
                # 관계가 있지만 안전하게 접근
                events_count = len(list(getattr(user, 'security_events', [])))
                logger.debug(f"[AUTH DEBUG] User has {events_count} security events")
        except Exception as e:
            logger.error(f"[AUTH DEBUG] Error accessing security_events: {str(e)}")
            # security_events 관련 오류가 있지만 인증은 계속 진행
        
        return user
    except Exception as e:
        logger.error(f"[AUTH DEBUG] Database query error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Authentication error: {str(e)}",
        )

def get_current_admin(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    user = get_current_user(token, db)
    # Safe check for admin attribute
    is_admin = getattr(user, 'is_admin', False)
    if not is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized as admin",
        )
    return user
