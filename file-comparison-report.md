# Casino-Club F2P File Comparison Report
Generated: 2025-08-07 19:24:34

This report analyzes the differences between duplicate files in the project to help with consolidation.

## Main Files Comparison

### Comparing main.py vs main_fixed.py
`diff
diff --git "a/cc-webapp\\backend\\app\\main.py" "b/cc-webapp\\backend\\app\\main_fixed.py" index 34303c4..254ef6c 100644 --- "a/cc-webapp\\backend\\app\\main.py" +++ "b/cc-webapp\\backend\\app\\main_fixed.py" @@ -42,7 +42,8 @@ from app.routers import (      notifications,      doc_titles,  # Phase 1 added      feedback,    # Phase 2 added -    games,       # Phase 3 added - 통합된 게임 API +    # games,       # Phase 3 added - 통합된 게임 API (Replaced with games_direct) +    games_direct, # Fixed games router - direct JSON response      # game_api,    # 중복 제거: games.router에 통합됨      invite_router,  # Phase 5 added      analyze,     # Phase 6 added @@ -140,7 +141,7 @@ app.add_middleware(    # Authentication & User Management (no prefix - routers have their own)  app.include_router(auth.router, tags=["Authentication"]) -app.include_router(users.router)  # 태그 오버라이드 제거 - 이미 users.py에서 "Users" 태그를 지정함 +app.include_router(users.router, tags=["Users"])    app.include_router(admin.router)  # 태그 오버라이드 제거 - 이미 admin.py에서 "Admin" 태그를 지정함    # Core Game Systems (no prefix - routers have their own) @@ -171,7 +172,8 @@ app.include_router(doc_titles.router, tags=["Document Titles"])  app.include_router(feedback.router, tags=["Feedback"])    # Phase 3: Game Collection (no prefix - routers have their own) - 통합된 게임 API -app.include_router(games.router, tags=["Game Collection"]) +# Replaced games router with games_direct +app.include_router(games_direct.router, tags=["Game Collection"])    # Phase 4: Unified Game API (no prefix - routers have their own) - 중복 제거  # app.include_router(game_api.router, tags=["Game API"])  # 중복 제거: games.router에 통합됨 @@ -197,6 +199,7 @@ app.include_router(events.router)  # 태그 오버라이드 제거 - 이미 even  print("✅ Core API endpoints registered")  print("✅ Progressive Expansion features registered")   print("✅ No duplicate API registrations - Clean structure maintained") +print("✅ Using games_direct router with improved JSON responses")    # ===== Core API Endpoints =====   @@ -310,8 +313,3 @@ if __name__ == "__main__":          reload=True,          log_level="info"      ) - -# 테스트용 라우터 추가 -from app.auth.test_endpoints import router as test_router -app.include_router(test_router) -
`

### Key differences:
- [ANALYZE] Differences need manual review

### Comparing main.py vs main_simple.py
`diff
diff --git "a/cc-webapp\\backend\\app\\main.py" "b/cc-webapp\\backend\\app\\main_simple.py" index 34303c4..fee6b95 100644 --- "a/cc-webapp\\backend\\app\\main.py" +++ "b/cc-webapp\\backend\\app\\main_simple.py" @@ -1,317 +1,39 @@ -#!/usr/bin/env python3 -# -*- coding: utf-8 -*- - -""" -Casino-Club F2P Backend Main Application -====================================== -Core FastAPI application with essential routers and middleware -""" - -import os -import logging -from datetime import datetime -from typing import Optional - -from fastapi import FastAPI, HTTPException, Depends, status +"""단순화된 FastAPI 메인 앱""" +from fastapi import FastAPI  from fastapi.middleware.cors import CORSMiddleware -from fastapi.responses import JSONResponse -from pydantic import BaseModel - -# Core imports -from app.database import get_db -from app.core.logging import setup_logging -from app.middleware.simple_logging import SimpleLoggingMiddleware -# from app.core.exceptions import add_exception_handlers  # Disabled - empty file -# from app.middleware.error_handling import error_handling_middleware  # Disabled -# from app.middleware.logging import LoggingContextMiddleware  # Disabled - -# Import core routers only -from app.routers import ( -    auth, -    users,  # Re-enabled -    admin, -    actions, -    # gacha,  # 중복 제거: games.router에 포함됨 -    rewards, -    shop, -    missions, -    quiz,        # Quiz system enabled -    dashboard, -    # prize_roulette,  # ARCHIVED - 룰렛 기능 제거 -    rps, -    notifications, -    doc_titles,  # Phase 1 added -    feedback,    # Phase 2 added -    games,       # Phase 3 added - 통합된 게임 API -    # game_api,    # 중복 제거: games.router에 통합됨 -    invite_router,  # Phase 5 added -    analyze,     # Phase 6 added -    # roulette,    # ARCHIVED - 룰렛 기능 제거 -    segments,    # Phase 8 added -    tracking,    # Phase 9 added -    unlock,      # Phase 10 added -    chat,        # Chat system added -    ai_router,   # AI recommendation system -    events,      # 추가 - 이벤트/미션 라우터 -) - -# AI recommendation system router separate import (removed duplicate) - -# Scheduler setup -class _DummyScheduler: -    running = False -    def shutdown(self, wait: bool = False) -> None: -        """No-op shutdown when scheduler is unavailable.""" - -try: -    from app.apscheduler_jobs import start_scheduler, scheduler -except Exception: -    def start_scheduler(): -        print("Scheduler disabled or APScheduler not installed") -    scheduler = _DummyScheduler() - -# Optional monitoring -try: -    from prometheus_fastapi_instrumentator import Instrumentator -except ImportError: -    Instrumentator = None - -try: -    import sentry_sdk -except Exception: -    sentry_sdk = None +import logging   -# ===== FastAPI App Initialization ===== +from .routers import auth_simple +from . import database   -app = FastAPI( -    title="Casino-Club F2P API", -    description="Backend API for Casino-Club F2P gaming platform", -    version="1.0.0", -    docs_url="/docs", -    redoc_url="/redoc", +# 로깅 설정 +logging.basicConfig( +    level=logging.DEBUG, +    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",  )   -# ===== Request/Response Models ===== - -class HealthResponse(BaseModel): -    status: str -    timestamp: datetime -    version: str - -class LoginRequest(BaseModel): -    user_id: str -    password: str - -class LoginResponse(BaseModel): -    token: str -    user_id: str -    message: Optional[str] = None - -# ===== Middleware Setup ===== - -# CORS settings -origins = [ -    "http://localhost:3000", -    "http://127.0.0.1:3000", -    "https://localhost:3000", -    "https://127.0.0.1:3000", -    "http://139.180.155.143:3000", -    "https://139.180.155.143:3000", -] +# 앱 생성 +app = FastAPI(title="Casino-Club F2P API - 단순 버전")   -# Error handlers (disabled - files empty) -# add_exception_handlers(app) - -# 간단한 API 로깅 미들웨어 추가 -app.add_middleware(SimpleLoggingMiddleware) - -# Middleware registration (disabled - files missing) -# app.add_middleware(error_handling_middleware) -# app.add_middleware(LoggingContextMiddleware) +# CORS 설정  app.add_middleware(      CORSMiddleware, -    allow_origins=origins, +    allow_origins=["*"],  # 개발용으로 모든 출처 허용      allow_credentials=True,      allow_methods=["*"],      allow_headers=["*"],  )   -# ===== Core API Router Registration ===== - -# Authentication & User Management (no prefix - routers have their own) -app.include_router(auth.router, tags=["Authentication"]) -app.include_router(users.router)  # 태그 오버라이드 제거 - 이미 users.py에서 "Users" 태그를 지정함 -app.include_router(admin.router)  # 태그 오버라이드 제거 - 이미 admin.py에서 "Admin" 태그를 지정함 - -# Core Game Systems (no prefix - routers have their own) -app.include_router(actions.router, tags=["Game Actions"]) -# app.include_router(gacha.router, tags=["Gacha"])  # 중복 제거: games.router에 포함됨 -app.include_router(rewards.router, tags=["Rewards"]) -app.include_router(shop.router, tags=["Shop"]) -app.include_router(missions.router)  # 태그 오버라이드 제거 - 이미 missions.py에서 "Events & Missions" 태그를 지정함 - -# Interactive Features (no prefix - routers have their own) -app.include_router(quiz.router)  # 태그 오버라이드 제거 - 이미 quiz_router.py에서 "Quiz" 태그를 지정함 -app.include_router(chat.router)  # 태그 오버라이드 제거 - 이미 chat_router.py에서 "Chat" 태그를 지정함 -app.include_router(ai_router.router, tags=["AI Recommendation"]) - -# Management & Monitoring (no prefix - routers have their own) -app.include_router(dashboard.router)  # 태그 오버라이드 제거 - 이미 dashboard.py에서 "Dashboard" 태그를 지정함 -app.include_router(notifications.router, tags=["Real-time Notifications"]) - -# Individual Games (no prefix - routers have their own) -app.include_router(rps.router, tags=["Rock Paper Scissors"]) - -# ===== Progressive Expansion - Additional Features ===== - -# Phase 1: Documentation & Content (no prefix - routers have their own) -app.include_router(doc_titles.router, tags=["Document Titles"]) - -# Phase 2: Feedback System (no prefix - routers have their own)   -app.include_router(feedback.router, tags=["Feedback"]) - -# Phase 3: Game Collection (no prefix - routers have their own) - 통합된 게임 API -app.include_router(games.router, tags=["Game Collection"]) - -# Phase 4: Unified Game API (no prefix - routers have their own) - 중복 제거 -# app.include_router(game_api.router, tags=["Game API"])  # 중복 제거: games.router에 통합됨 - -# Phase 5: Invite System (no prefix - routers have their own) -app.include_router(invite_router.router)  # 태그 오버라이드 제거 - 이미 invite_router.py에서 "Invite Codes" 태그를 지정함 - -# Phase 6: Analytics (no prefix - routers have their own) -app.include_router(analyze.router, tags=["Analytics"]) - -# Phase 8: User Segmentation (no prefix - routers have their own)   -app.include_router(segments.router)  # 태그 오버라이드 제거 - 이미 segments.py에서 "Segments" 태그를 지정함 - -# Phase 9: User Tracking (no prefix - routers have their own) -app.include_router(tracking.router, tags=["Tracking"]) - -# Phase 10: Unlock System (no prefix - routers have their own) -app.include_router(unlock.router, tags=["Unlock"]) - -# 이벤트/미션 라우터 추가 -app.include_router(events.router)  # 태그 오버라이드 제거 - 이미 events.py에서 "Events & Missions" 태그를 지정함 - -print("✅ Core API endpoints registered") -print("✅ Progressive Expansion features registered")  -print("✅ No duplicate API registrations - Clean structure maintained") - -# ===== Core API Endpoints ===== - -@app.get("/", tags=["Root"]) -async def root(): -    """Root endpoint""" -    return { -        "message": "Casino-Club F2P Backend API", -        "version": "1.0.0", -        "status": "running", -        "docs": "/docs" -    } - -@app.get("/health", response_model=HealthResponse, tags=["Health"]) -async def health_check(): -    """Health check endpoint""" -    return HealthResponse( -        status="healthy", -        timestamp=datetime.now(), -        version="1.0.0" -    ) - -@app.get("/api", tags=["API Info"]) -async def api_info(): -    """API information endpoint""" -    return { -        "title": "Casino-Club F2P API", -        "version": "1.0.0", -        "description": "Backend API for Casino-Club F2P gaming platform", -        "endpoints": { -            "auth": "/api/auth", -            "users": "/api/users", -            "admin": "/api/admin", -            "games": "/api/actions, /api/gacha, /api/games/*", -            "shop": "/api/shop, /api/rewards", -            "missions": "/api/missions", -            "quiz": "/api/quiz", -            "dashboard": "/api/dashboard", -            "websocket": "/ws" -        } -    } - -# ===== Application Lifecycle Events ===== - -@app.on_event("startup") -async def startup_event(): -    """Application startup event""" -    print("🚀 Casino-Club F2P Backend starting up...") -     -    # Initialize logging -    try: -        setup_logging() -        print("📋 Logging initialized") -    except Exception as e: -        print(f"⚠️ Logging setup failed: {e}") -     -    # Start scheduler -    start_scheduler() -     -    # Note: Prometheus monitoring disabled to avoid middleware timing issue -    # if Instrumentator: -    #     Instrumentator().instrument(app).expose(app) -    #     print("📊 Prometheus monitoring enabled") -     -    print("✅ Backend startup complete") - -@app.on_event("shutdown") -async def shutdown_event(): -    """Application shutdown event""" -    print("🛑 Casino-Club F2P Backend shutting down...") -     -    # Shutdown scheduler -    if scheduler and scheduler.running: -        scheduler.shutdown(wait=True) -        print("⏱️ Scheduler stopped") -     -    print("✅ Backend shutdown complete") - -# ===== Error Handlers ===== - -@app.exception_handler(404) -async def not_found_handler(request, exc): -    """Custom 404 handler""" -    return JSONResponse( -        status_code=404, -        content={ -            "error": "Not Found", -            "message": f"The requested endpoint {request.url.path} was not found", -            "available_endpoints": "/docs" -        } -    ) - -@app.exception_handler(500) -async def internal_error_handler(request, exc): -    """Custom 500 handler""" -    return JSONResponse( -        status_code=500, -        content={ -            "error": "Internal Server Error", -            "message": "An unexpected error occurred", -            "timestamp": datetime.now().isoformat() -        } -    ) +# 라우터 등록 +app.include_router(auth_simple.router)   -if __name__ == "__main__": -    import uvicorn -    uvicorn.run( -        "main:app", -        host="0.0.0.0", -        port=8000, -        reload=True, -        log_level="info" -    ) +# 데이터베이스 초기화 +database.Base.metadata.create_all(bind=database.engine)   -# 테스트용 라우터 추가 -from app.auth.test_endpoints import router as test_router -app.include_router(test_router) +@app.get("/") +def read_root(): +    return {"message": "Casino-Club F2P API - 단순 버전이 실행 중입니다"}   +@app.get("/api/health") +def health_check(): +    return {"status": "ok", "message": "시스템이 정상적으로 실행 중입니다"}
`

### Key differences:
- [ANALYZE] Differences need manual review

## Auth Files Comparison

### Comparing auth.py vs auth_clean.py
`diff
diff --git "a/cc-webapp\\backend\\app\\routers\\auth.py" "b/cc-webapp\\backend\\app\\routers\\auth_clean.py" index 622c937..77fbb0e 100644 --- "a/cc-webapp\\backend\\app\\routers\\auth.py" +++ "b/cc-webapp\\backend\\app\\routers\\auth_clean.py" @@ -1,277 +1,24 @@ -"""통합된 인증 API 라우터 - -Casino-Club F2P - 인증 시스# 라우터 정의 -router = APIRouter( -    prefix="/api/auth", -    tags=["authentication"] -) - -def get_auth_service(db: Session = Depends(get_db)) -> AuthService: -    """AuthService 인스턴스 생성""" -    return AuthService(db) - -@router.post("/login", response_model=Token) -async def login( -    form_data: UserLogin, -    auth_service: AuthService = Depends(get_auth_service), -    request: Request = None -): -    """일반 사용자 로그인""" -    user = auth_service.authenticate_user(form_data.site_id, form_data.password) -    if not user: -        raise HTTPException( -            status_code=status.HTTP_401_UNAUTHORIZED, -            detail="Incorrect username or password" -        ) -     -    # 액세스 토큰 생성 -    access_token_data = { -        "sub": str(user.id), -        "site_id": user.site_id, -        "is_admin": user.is_admin -    } -    access_token = auth_service.create_access_token(access_token_data) -     -    # 리프레시 토큰 생성 -    refresh_token_data = { -        "sub": str(user.id), -        "site_id": user.site_id -    } -    refresh_token = auth_service.create_refresh_token(refresh_token_data) -     -    # 응답 -    return { -        "access_token": access_token, -        "refresh_token": refresh_token, -        "token_type": "bearer", -        "user": user -    } - -@router.post("/admin/login", response_model=Token) -async def admin_login( -    form_data: AdminLogin, -    auth_service: AuthService = Depends(get_auth_service), -    request: Request = None -): -    """관리자 로그인""" -    user = auth_service.authenticate_admin(form_data.site_id, form_data.password) -    if not user: -        raise HTTPException( -            status_code=status.HTTP_401_UNAUTHORIZED, -            detail="Incorrect username or password or not admin" -        ) -     -    # 액세스 토큰 생성 -    access_token_data = { -        "sub": str(user.id), -        "site_id": user.site_id, -        "is_admin": True -    } -    access_token = auth_service.create_access_token(access_token_data) -     -    # 리프레시 토큰 생성 -    refresh_token_data = { -        "sub": str(user.id), -        "site_id": user.site_id, -        "is_admin": True -    } -    refresh_token = auth_service.create_refresh_token(refresh_token_data) -     -    # 응답 -    return { -        "access_token": access_token, -        "refresh_token": refresh_token, -        "token_type": "bearer", -        "user": user -    } - -@router.post("/refresh", response_model=Token) -async def refresh_token( -    refresh_request: RefreshTokenRequest, -    auth_service: AuthService = Depends(get_auth_service) -): -    """리프레시 토큰으로 새 액세스 토큰 발급""" -    try: -        # 리프레시 토큰 검증 -        payload = auth_service.verify_refresh_token(refresh_request.refresh_token) -         -        # 새 액세스 토큰 생성 -        access_token_data = { -            "sub": payload["sub"], -            "site_id": payload["site_id"] -        } -        if "is_admin" in payload: -            access_token_data["is_admin"] = payload["is_admin"] -             -        new_access_token = auth_service.create_access_token(access_token_data) -         -        # 유저 정보 조회 -        user_id = int(payload["sub"]) -        user = auth_service.db.query(User).filter(User.id == user_id).first() -        if not user: -            raise HTTPException( -                status_code=status.HTTP_404_NOT_FOUND, -                detail="User not found" -            ) -         -        # 응답 -        return { -            "access_token": new_access_token, -            "refresh_token": refresh_request.refresh_token,  # 기존 리프레시 토큰 유지 -            "token_type": "bearer", -            "user": user -        } -         -    except HTTPException as e: -        raise e -    except Exception as e: -        raise HTTPException( -            status_code=status.HTTP_401_UNAUTHORIZED, -            detail=f"Could not validate refresh token: {str(e)}" -        ) - -@router.post("/logout") -async def logout( -    logout_request: LogoutRequest, -    auth_service: AuthService = Depends(get_auth_service), -    current_user: User = Depends(get_current_user) -): -    """로그아웃 - 토큰 블랙리스트 추가""" -    # 현재 액세스 토큰 블랙리스트에 추가 -    token = auth_service.blacklist_token(logout_request.refresh_token, reason="logout") -    if not token: -        raise HTTPException( -            status_code=status.HTTP_400_BAD_REQUEST, -            detail="Could not blacklist token" -        ) -     -    return {"message": "Successfully logged out"}============================================================================ -기능: -- 초대 코드를 통한 회원가입 -- 아이디/비밀번호 로그인 -- JWT 토큰 관리 (액세스 + 리프레시) -- 세션 관리 및 보안 -- 토큰 블랙리스트 -- 로그아웃 -""" +"""Authentication API Router"""    import logging -from datetime import datetime, timedelta -from typing import Optional, Dict, Any -from fastapi import APIRouter, Depends, HTTPException, status, Request, Response -from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer, OAuth2PasswordRequestForm -from sqlalchemy.orm import Session +from datetime import datetime +from typing import Optional + +from fastapi import APIRouter, Depends, HTTPException, status, Request +from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer +from pydantic import BaseModel   -from ..auth.auth_service import AuthService  from ..database import get_db -from ..schemas.auth import ( -    UserCreate, UserLogin, AdminLogin, UserResponse, Token, -    RefreshTokenRequest, LogoutRequest -) -from ..models.auth_models import User +from ..schemas.auth import UserCreate, UserLogin, AdminLogin, UserResponse, Token +from ..services.auth_service import AuthService, security +from ..models.auth_models import User, InviteCode  from ..config import settings -from ..dependencies import get_current_user, get_current_admin_user   -# 로깅 설정 +# Logger setup  logger = logging.getLogger(__name__) -logger.setLevel(logging.DEBUG) - -# 콘솔 로그 핸들러 설정 -if not logger.handlers: -    handler = logging.StreamHandler() -    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') -    handler.setFormatter(formatter) -    logger.addHandler(handler)   -# HTTP 보안 스키마 -security = HTTPBearer() - -# 라우터 정의 -router = APIRouter( -    prefix="/api/auth", -    tags=["authentication"] -) - -    def create_access_token(self, data: dict, expires_delta: Optional[timedelta] = None) -> str: -        """JWT 액세스 토큰 생성""" -        try: -            to_encode = data.copy() -            expire = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.jwt_expire_minutes)) -            to_encode.update({"exp": expire}) -            encoded_jwt = jwt.encode(to_encode, settings.jwt_secret_key, algorithm=settings.jwt_algorithm) -            return encoded_jwt -        except Exception as e: -            logger.error(f"토큰 생성 중 오류 발생: {str(e)}") -            raise HTTPException( -                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -                detail="토큰 생성 중 오류가 발생했습니다." -            ) -     -    def create_user(self, user_data: UserCreate) -> User: -        """새로운 사용자 생성""" -        # 초대 코드 확인 -        invite_code = self.db.query(InviteCode).filter( -            InviteCode.code == user_data.invite_code, -            InviteCode.is_active == True -        ).first() -         -        if not invite_code or (invite_code.code != "5858" and invite_code.is_used): -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="유효하지 않은 초대 코드입니다." -            ) -             -        # 비밀번호 유효성 검사 -        if len(user_data.password) < 4: -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="비밀번호는 4자리 이상이어야 합니다." -            ) -             -        # 중복 검사 -        if self.db.query(User).filter(User.site_id == user_data.site_id).first(): -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="이미 사용 중인 아이디입니다." -            ) -        if self.db.query(User).filter(User.nickname == user_data.nickname).first(): -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="이미 사용 중인 닉네임입니다." -            ) -        if self.db.query(User).filter(User.phone_number == user_data.phone_number).first(): -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="이미 등록된 전화번호입니다." -            ) -             -        # 사용자 생성 -        hashed_password = self.pwd_context.hash(user_data.password) -        user = User( -            site_id=user_data.site_id, -            password_hash=hashed_password, -            nickname=user_data.nickname, -            phone_number=user_data.phone_number, -            invite_code=user_data.invite_code -        ) -         -        try: -            self.db.add(user) -            # 초대 코드가 5858이 아닌 경우에만 used 처리 -            if invite_code.code != "5858": -                invite_code.is_used = True -                invite_code.used_by_user_id = user.id -                invite_code.used_at = datetime.utcnow() -            self.db.commit() -            self.db.refresh(user) -            return user -        except Exception as e: -            self.db.rollback() -            logger.error(f"회원가입 처리 중 오류 발생: {str(e)}") -            raise HTTPException( -                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -                detail="회원가입 처리 중 오류가 발생했습니다." -            ) +# Auth service instance +auth_service = AuthService()    # OAuth2 schema  oauth2_scheme = HTTPBearer() @@ -280,50 +27,26 @@ oauth2_scheme = HTTPBearer()  JWT_EXPIRE_MINUTES = settings.jwt_expire_minutes  INITIAL_CYBER_TOKENS = getattr(settings, 'initial_cyber_tokens', 200)   -# 라우터 설정 -router = APIRouter( -    prefix="/api/auth", -    tags=["Authentication"], -    responses={401: {"description": "인증 오류"}} -) - -# 인증 서비스 의존성 -def get_auth_service(db: Session = Depends(get_db)) -> AuthService: -    return AuthService(db) +router = APIRouter(tags=["authentication"])    @router.post("/signup", response_model=Token)  async def signup(      data: UserCreate, -    db: Session = Depends(get_db), -    auth_service: AuthService = Depends(get_auth_service) +    db = Depends(get_db)  ): -    """사용자 등록 (회원가입) -     -    - site_id와 nickname을 이용한 회원가입 -    - 비밀번호는 4글자 이상 -    - 초대 코드 '5858' 사용 -    """ +    """User registration (5 required fields: site_id, nickname, phone_number, invite_code, password)"""      try: -        logger.info(f"회원가입 시도: site_id={data.site_id}, nickname={data.nickname}") -         -        # 비밀번호 검증 -        if len(data.password) < 4: -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="비밀번호는 4글자 이상이어야 합니다" -            ) +        logger.info(f"Registration attempt: site_id={data.site_id}, nickname={data.nickname}")           -        # 사용자 생성 -        user = auth_service.create_user(data) +        # Create user through AuthService +        user = auth_service.create_user(db, data)           -        # JWT 토큰 생성 -        access_token = auth_service.create_access_token({ -            "sub": user.site_id, -            "user_id": user.id, -            "is_admin": user.is_admin -        }) +        # Generate token +        access_token = auth_service.create_access_token( +            data={"sub": user.site_id, "user_id": user.id} +        )           -        # 응답 데이터 생성 +        # Create user response data          user_response = UserResponse(              id=user.id,              site_id=user.site_id, @@ -331,57 +54,53 @@ async def signup(              phone_number=user.phone_number,              cyber_token_balance=user.cyber_token_balance,              created_at=user.created_at, -            last_login=user.last_login or user.created_at,  # last_login이 None이면 created_at 사용 +            last_login=user.last_login,              is_admin=user.is_admin,              is_active=user.is_active          )           -        logger.info(f"회원가입 성공: user_id={user.id}") +        logger.info(f"Registration successful: user_id={user.id}")                    return Token(              access_token=access_token,              token_type="bearer",              user=user_response          ) +              except HTTPException:          raise      except Exception as e: -        logger.error(f"회원가입 오류: {str(e)}") -        raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="회원가입 처리 중 오류가 발생했습니다" -        ) +        logger.error(f"Signup error: {e}") +        raise HTTPException(status_code=500, detail="Registration processing error occurred")   -# 로그인 라우터 수정 - 올바른 응답 포맷으로 변경  @router.post("/login", response_model=Token)  async def login( -    form_data: OAuth2PasswordRequestForm = Depends(), -    db: Session = Depends(get_db), -    auth_service: AuthService = Depends(get_auth_service) +    form_data: UserLogin, +    db = Depends(get_db)  ): -    """사용자 로그인""" +    """User login"""      try: -        # 사용자 인증 -        user = auth_service.authenticate_user(form_data.username, form_data.password) +        logger.info(f"Login attempt: site_id={form_data.site_id}") +         +        # Authenticate user through AuthService +        user = auth_service.authenticate_user(db, form_data.site_id, form_data.password) +                  if not user:              raise HTTPException(                  status_code=status.HTTP_401_UNAUTHORIZED, -                detail="아이디 또는 비밀번호가 잘못되었습니다", +                detail="Invalid site_id or password",                  headers={"WWW-Authenticate": "Bearer"},              ) -             -        # JWT 토큰 생성 -        access_token = auth_service.create_access_token({ -            "sub": user.site_id, -            "user_id": user.id, -            "is_admin": user.is_admin -        })           -        # 마지막 로그인 시간 업데이트 -        user.last_login = datetime.utcnow() -        db.commit() +        # Generate access token +        access_token = auth_service.create_access_token( +            data={"sub": user.site_id, "user_id": user.id} +        ) +         +        # Update last login time +        auth_service.update_last_login(db, user.id)           -        # 응답 데이터 생성 +        # Create user response          user_response = UserResponse(              id=user.id,              site_id=user.site_id, @@ -389,112 +108,53 @@ async def login(              phone_number=user.phone_number,              cyber_token_balance=user.cyber_token_balance,              created_at=user.created_at, -            last_login=user.last_login, +            last_login=datetime.now(),              is_admin=user.is_admin,              is_active=user.is_active          )           +        logger.info(f"Login successful: user_id={user.id}") +                  return Token(              access_token=access_token,              token_type="bearer",              user=user_response          ) +              except HTTPException:          raise      except Exception as e: -        logger.error(f"로그인 오류: {str(e)}") -        raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="로그인 처리 중 오류가 발생했습니다" -        ) +        logger.error(f"Login error: {e}") +        raise HTTPException(status_code=500, detail="Login processing error occurred")    @router.post("/admin/login", response_model=Token)  async def admin_login(      form_data: AdminLogin, -    db: Session = Depends(get_db), -    auth_service: AuthService = Depends(get_auth_service) +    db = Depends(get_db)  ): -    """관리자 로그인""" +    """Admin login"""      try: -        logger.info(f"관리자 로그인 시도: site_id={form_data.site_id}") +        logger.info(f"Admin login attempt: site_id={form_data.site_id}") +         +        # Admin authentication through AuthService +        user = auth_service.authenticate_admin(db, form_data.site_id, form_data.password)           -        # 관리자 인증 -        user = auth_service.authenticate_admin(form_data.site_id, form_data.password)          if not user:              raise HTTPException(                  status_code=status.HTTP_401_UNAUTHORIZED, -                detail="관리자 인증에 실패했습니다", +                detail="Invalid admin credentials",                  headers={"WWW-Authenticate": "Bearer"},              ) -             -        # JWT 토큰 생성 -        access_token = auth_service.create_access_token({ -            "sub": user.site_id, -            "user_id": user.id, -            "is_admin": user.is_admin -        })           -        # 마지막 로그인 시간 업데이트 -        user.last_login = datetime.utcnow() -        db.commit() -         -        # 응답 데이터 생성 -        user_response = UserResponse( -            id=user.id, -            site_id=user.site_id, -            nickname=user.nickname, -            phone_number=user.phone_number, -            cyber_token_balance=user.cyber_token_balance, -            created_at=user.created_at, -            last_login=user.last_login, -            is_admin=user.is_admin, -            is_active=user.is_active +        # Generate access token +        access_token = auth_service.create_access_token( +            data={"sub": user.site_id, "user_id": user.id, "is_admin": True}          )           -        logger.info(f"관리자 로그인 성공: user_id={user.id}") +        # Update last login time +        auth_service.update_last_login(db, user.id)           -        return Token( -            access_token=access_token, -            token_type="bearer", -            user=user_response -        ) -    except HTTPException: -        raise -    except Exception as e: -        logger.error(f"관리자 로그인 오류: {str(e)}") -        raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="관리자 로그인 처리 중 오류가 발생했습니다" -        ) - -@router.post("/refresh", response_model=Token) -async def refresh_token( -    credentials: HTTPAuthorizationCredentials = Depends(security), -    db: Session = Depends(get_db), -    auth_service: AuthService = Depends(get_auth_service) -): -    """토큰 갱신""" -    logger.info("API: POST /api/auth/refresh - 토큰 갱신 요청") -    try: -        # 현재 토큰에서 사용자 정보 추출 -        token_data = auth_service.verify_token(credentials.credentials) -         -        # 사용자 조회 -        user = db.query(User).filter(User.id == token_data.user_id).first() -        if not user: -            raise HTTPException( -                status_code=status.HTTP_401_UNAUTHORIZED, -                detail="사용자를 찾을 수 없습니다" -            ) -         -        # 새 토큰 생성 -        new_access_token = auth_service.create_access_token({ -            "sub": user.site_id, -            "user_id": user.id, -            "is_admin": user.is_admin -        }) -         -        # 사용자 응답 데이터 생성 +        # Create user response          user_response = UserResponse(              id=user.id,              site_id=user.site_id, @@ -502,45 +162,21 @@ async def refresh_token(              phone_number=user.phone_number,              cyber_token_balance=user.cyber_token_balance,              created_at=user.created_at, -            last_login=user.last_login or user.created_at, +            last_login=datetime.now(),              is_admin=user.is_admin,              is_active=user.is_active          )           -        logger.info(f"토큰 갱신 성공: user_id={user.id}") +        logger.info(f"Admin login successful: user_id={user.id}")                    return Token( -            access_token=new_access_token, +            access_token=access_token,              token_type="bearer",              user=user_response          ) -    except HTTPException: -        raise -    except Exception as e: -        logger.error(f"토큰 갱신 오류: {str(e)}") -        raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="토큰 갱신 중 오류가 발생했습니다" -        ) - -@router.post("/logout") -async def logout( -    credentials: HTTPAuthorizationCredentials = Depends(security), -    auth_service: AuthService = Depends(get_auth_service) -): -    """로그아웃""" -    logger.info("API: POST /api/auth/logout - 로그아웃 요청") -    try: -        # 토큰 검증만 수행 (실제로는 토큰 블랙리스트 등을 구현할 수 있음) -        token_data = auth_service.verify_token(credentials.credentials) -        logger.info(f"로그아웃 성공: user_id={token_data.user_id}")           -        return {"message": "로그아웃되었습니다"}      except HTTPException:          raise      except Exception as e: -        logger.error(f"로그아웃 오류: {str(e)}") -        raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="로그아웃 처리 중 오류가 발생했습니다" -        ) +        logger.error(f"Admin login error: {e}") +        raise HTTPException(status_code=500, detail="Admin login processing error occurred")
`

### Key differences:
- [ANALYZE] Differences need manual review

### Comparing auth.py vs auth_simple.py
`diff
diff --git "a/cc-webapp\\backend\\app\\routers\\auth.py" "b/cc-webapp\\backend\\app\\routers\\auth_simple.py" index 622c937..adc0589 100644 --- "a/cc-webapp\\backend\\app\\routers\\auth.py" +++ "b/cc-webapp\\backend\\app\\routers\\auth_simple.py" @@ -1,176 +1,15 @@ -"""통합된 인증 API 라우터 - -Casino-Club F2P - 인증 시스# 라우터 정의 -router = APIRouter( -    prefix="/api/auth", -    tags=["authentication"] -) - -def get_auth_service(db: Session = Depends(get_db)) -> AuthService: -    """AuthService 인스턴스 생성""" -    return AuthService(db) - -@router.post("/login", response_model=Token) -async def login( -    form_data: UserLogin, -    auth_service: AuthService = Depends(get_auth_service), -    request: Request = None -): -    """일반 사용자 로그인""" -    user = auth_service.authenticate_user(form_data.site_id, form_data.password) -    if not user: -        raise HTTPException( -            status_code=status.HTTP_401_UNAUTHORIZED, -            detail="Incorrect username or password" -        ) -     -    # 액세스 토큰 생성 -    access_token_data = { -        "sub": str(user.id), -        "site_id": user.site_id, -        "is_admin": user.is_admin -    } -    access_token = auth_service.create_access_token(access_token_data) -     -    # 리프레시 토큰 생성 -    refresh_token_data = { -        "sub": str(user.id), -        "site_id": user.site_id -    } -    refresh_token = auth_service.create_refresh_token(refresh_token_data) -     -    # 응답 -    return { -        "access_token": access_token, -        "refresh_token": refresh_token, -        "token_type": "bearer", -        "user": user -    } - -@router.post("/admin/login", response_model=Token) -async def admin_login( -    form_data: AdminLogin, -    auth_service: AuthService = Depends(get_auth_service), -    request: Request = None -): -    """관리자 로그인""" -    user = auth_service.authenticate_admin(form_data.site_id, form_data.password) -    if not user: -        raise HTTPException( -            status_code=status.HTTP_401_UNAUTHORIZED, -            detail="Incorrect username or password or not admin" -        ) -     -    # 액세스 토큰 생성 -    access_token_data = { -        "sub": str(user.id), -        "site_id": user.site_id, -        "is_admin": True -    } -    access_token = auth_service.create_access_token(access_token_data) -     -    # 리프레시 토큰 생성 -    refresh_token_data = { -        "sub": str(user.id), -        "site_id": user.site_id, -        "is_admin": True -    } -    refresh_token = auth_service.create_refresh_token(refresh_token_data) -     -    # 응답 -    return { -        "access_token": access_token, -        "refresh_token": refresh_token, -        "token_type": "bearer", -        "user": user -    } - -@router.post("/refresh", response_model=Token) -async def refresh_token( -    refresh_request: RefreshTokenRequest, -    auth_service: AuthService = Depends(get_auth_service) -): -    """리프레시 토큰으로 새 액세스 토큰 발급""" -    try: -        # 리프레시 토큰 검증 -        payload = auth_service.verify_refresh_token(refresh_request.refresh_token) -         -        # 새 액세스 토큰 생성 -        access_token_data = { -            "sub": payload["sub"], -            "site_id": payload["site_id"] -        } -        if "is_admin" in payload: -            access_token_data["is_admin"] = payload["is_admin"] -             -        new_access_token = auth_service.create_access_token(access_token_data) -         -        # 유저 정보 조회 -        user_id = int(payload["sub"]) -        user = auth_service.db.query(User).filter(User.id == user_id).first() -        if not user: -            raise HTTPException( -                status_code=status.HTTP_404_NOT_FOUND, -                detail="User not found" -            ) -         -        # 응답 -        return { -            "access_token": new_access_token, -            "refresh_token": refresh_request.refresh_token,  # 기존 리프레시 토큰 유지 -            "token_type": "bearer", -            "user": user -        } -         -    except HTTPException as e: -        raise e -    except Exception as e: -        raise HTTPException( -            status_code=status.HTTP_401_UNAUTHORIZED, -            detail=f"Could not validate refresh token: {str(e)}" -        ) - -@router.post("/logout") -async def logout( -    logout_request: LogoutRequest, -    auth_service: AuthService = Depends(get_auth_service), -    current_user: User = Depends(get_current_user) -): -    """로그아웃 - 토큰 블랙리스트 추가""" -    # 현재 액세스 토큰 블랙리스트에 추가 -    token = auth_service.blacklist_token(logout_request.refresh_token, reason="logout") -    if not token: -        raise HTTPException( -            status_code=status.HTTP_400_BAD_REQUEST, -            detail="Could not blacklist token" -        ) -     -    return {"message": "Successfully logged out"}============================================================================ -기능: -- 초대 코드를 통한 회원가입 -- 아이디/비밀번호 로그인 -- JWT 토큰 관리 (액세스 + 리프레시) -- 세션 관리 및 보안 -- 토큰 블랙리스트 -- 로그아웃 -""" - -import logging +"""단순화된 인증 라우터"""  from datetime import datetime, timedelta -from typing import Optional, Dict, Any -from fastapi import APIRouter, Depends, HTTPException, status, Request, Response -from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer, OAuth2PasswordRequestForm +from fastapi import APIRouter, Depends, HTTPException, status +from fastapi.security import OAuth2PasswordRequestForm +from jose import jwt  from sqlalchemy.orm import Session - -from ..auth.auth_service import AuthService  from ..database import get_db -from ..schemas.auth import ( -    UserCreate, UserLogin, AdminLogin, UserResponse, Token, -    RefreshTokenRequest, LogoutRequest -) -from ..models.auth_models import User -from ..config import settings -from ..dependencies import get_current_user, get_current_admin_user +from ..models.simple_auth_models import User, InviteCode +from ..dependencies_simple import get_current_user +from ..config_simple import settings +from passlib.context import CryptContext +import logging    # 로깅 설정  logger = logging.getLogger(__name__) @@ -183,364 +22,125 @@ if not logger.handlers:      handler.setFormatter(formatter)      logger.addHandler(handler)   -# HTTP 보안 스키마 -security = HTTPBearer() +# 비밀번호 해싱 +pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")   -# 라우터 정의  router = APIRouter(      prefix="/api/auth", -    tags=["authentication"] +    tags=["auth"],  )   -    def create_access_token(self, data: dict, expires_delta: Optional[timedelta] = None) -> str: -        """JWT 액세스 토큰 생성""" -        try: -            to_encode = data.copy() -            expire = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.jwt_expire_minutes)) -            to_encode.update({"exp": expire}) -            encoded_jwt = jwt.encode(to_encode, settings.jwt_secret_key, algorithm=settings.jwt_algorithm) -            return encoded_jwt -        except Exception as e: -            logger.error(f"토큰 생성 중 오류 발생: {str(e)}") -            raise HTTPException( -                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -                detail="토큰 생성 중 오류가 발생했습니다." -            ) +def create_access_token(data: dict, expires_delta: timedelta = None): +    """JWT 액세스 토큰 생성""" +    to_encode = data.copy() +    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15)) +    to_encode.update({"exp": expire}) +    encoded_jwt = jwt.encode(to_encode, settings.jwt_secret_key, algorithm=settings.jwt_algorithm) +    return encoded_jwt + +@router.post("/login") +def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)): +    """로그인 엔드포인트""" +    logger.debug(f"[AUTH] Login attempt for username: {form_data.username}")       -    def create_user(self, user_data: UserCreate) -> User: -        """새로운 사용자 생성""" -        # 초대 코드 확인 -        invite_code = self.db.query(InviteCode).filter( -            InviteCode.code == user_data.invite_code, -            InviteCode.is_active == True -        ).first() -         -        if not invite_code or (invite_code.code != "5858" and invite_code.is_used): -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="유효하지 않은 초대 코드입니다." -            ) -             -        # 비밀번호 유효성 검사 -        if len(user_data.password) < 4: -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="비밀번호는 4자리 이상이어야 합니다." -            ) -             -        # 중복 검사 -        if self.db.query(User).filter(User.site_id == user_data.site_id).first(): -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="이미 사용 중인 아이디입니다." -            ) -        if self.db.query(User).filter(User.nickname == user_data.nickname).first(): -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="이미 사용 중인 닉네임입니다." -            ) -        if self.db.query(User).filter(User.phone_number == user_data.phone_number).first(): -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="이미 등록된 전화번호입니다." -            ) -             -        # 사용자 생성 -        hashed_password = self.pwd_context.hash(user_data.password) -        user = User( -            site_id=user_data.site_id, -            password_hash=hashed_password, -            nickname=user_data.nickname, -            phone_number=user_data.phone_number, -            invite_code=user_data.invite_code -        ) -         -        try: -            self.db.add(user) -            # 초대 코드가 5858이 아닌 경우에만 used 처리 -            if invite_code.code != "5858": -                invite_code.is_used = True -                invite_code.used_by_user_id = user.id -                invite_code.used_at = datetime.utcnow() -            self.db.commit() -            self.db.refresh(user) -            return user -        except Exception as e: -            self.db.rollback() -            logger.error(f"회원가입 처리 중 오류 발생: {str(e)}") -            raise HTTPException( -                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -                detail="회원가입 처리 중 오류가 발생했습니다." -            ) - -# OAuth2 schema -oauth2_scheme = HTTPBearer() - -# Configuration values -JWT_EXPIRE_MINUTES = settings.jwt_expire_minutes -INITIAL_CYBER_TOKENS = getattr(settings, 'initial_cyber_tokens', 200) - -# 라우터 설정 -router = APIRouter( -    prefix="/api/auth", -    tags=["Authentication"], -    responses={401: {"description": "인증 오류"}} -) - -# 인증 서비스 의존성 -def get_auth_service(db: Session = Depends(get_db)) -> AuthService: -    return AuthService(db) - -@router.post("/signup", response_model=Token) -async def signup( -    data: UserCreate, -    db: Session = Depends(get_db), -    auth_service: AuthService = Depends(get_auth_service) -): -    """사용자 등록 (회원가입) +    # 사용자 확인 +    user = db.query(User).filter(User.site_id == form_data.username).first()       -    - site_id와 nickname을 이용한 회원가입 -    - 비밀번호는 4글자 이상 -    - 초대 코드 '5858' 사용 -    """ -    try: -        logger.info(f"회원가입 시도: site_id={data.site_id}, nickname={data.nickname}") -         -        # 비밀번호 검증 -        if len(data.password) < 4: -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="비밀번호는 4글자 이상이어야 합니다" -            ) -         -        # 사용자 생성 -        user = auth_service.create_user(data) -         -        # JWT 토큰 생성 -        access_token = auth_service.create_access_token({ -            "sub": user.site_id, -            "user_id": user.id, -            "is_admin": user.is_admin -        }) -         -        # 응답 데이터 생성 -        user_response = UserResponse( -            id=user.id, -            site_id=user.site_id, -            nickname=user.nickname, -            phone_number=user.phone_number, -            cyber_token_balance=user.cyber_token_balance, -            created_at=user.created_at, -            last_login=user.last_login or user.created_at,  # last_login이 None이면 created_at 사용 -            is_admin=user.is_admin, -            is_active=user.is_active -        ) -         -        logger.info(f"회원가입 성공: user_id={user.id}") -         -        return Token( -            access_token=access_token, -            token_type="bearer", -            user=user_response -        ) -    except HTTPException: -        raise -    except Exception as e: -        logger.error(f"회원가입 오류: {str(e)}") +    # 사용자가 없거나 비밀번호가 일치하지 않는 경우 +    if not user or not pwd_context.verify(form_data.password, user.password_hash): +        logger.error(f"[AUTH] Login failed for username: {form_data.username}")          raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="회원가입 처리 중 오류가 발생했습니다" +            status_code=status.HTTP_401_UNAUTHORIZED, +            detail="사용자 이름 또는 비밀번호가 올바르지 않습니다", +            headers={"WWW-Authenticate": "Bearer"},          ) +     +    # 토큰 생성 +    access_token_expires = timedelta(minutes=settings.jwt_access_token_expire_minutes) +    access_token = create_access_token( +        data={"user_id": user.id, "sub": user.site_id}, +        expires_delta=access_token_expires, +    ) +     +    logger.debug(f"[AUTH] Login successful for user: {user.nickname}") +     +    return { +        "access_token": access_token, +        "token_type": "bearer", +        "user_id": user.id, +        "nickname": user.nickname, +    }   -# 로그인 라우터 수정 - 올바른 응답 포맷으로 변경 -@router.post("/login", response_model=Token) -async def login( -    form_data: OAuth2PasswordRequestForm = Depends(), -    db: Session = Depends(get_db), -    auth_service: AuthService = Depends(get_auth_service) -): -    """사용자 로그인""" -    try: -        # 사용자 인증 -        user = auth_service.authenticate_user(form_data.username, form_data.password) -        if not user: -            raise HTTPException( -                status_code=status.HTTP_401_UNAUTHORIZED, -                detail="아이디 또는 비밀번호가 잘못되었습니다", -                headers={"WWW-Authenticate": "Bearer"}, -            ) -             -        # JWT 토큰 생성 -        access_token = auth_service.create_access_token({ -            "sub": user.site_id, -            "user_id": user.id, -            "is_admin": user.is_admin -        }) -         -        # 마지막 로그인 시간 업데이트 -        user.last_login = datetime.utcnow() -        db.commit() -         -        # 응답 데이터 생성 -        user_response = UserResponse( -            id=user.id, -            site_id=user.site_id, -            nickname=user.nickname, -            phone_number=user.phone_number, -            cyber_token_balance=user.cyber_token_balance, -            created_at=user.created_at, -            last_login=user.last_login, -            is_admin=user.is_admin, -            is_active=user.is_active -        ) -         -        return Token( -            access_token=access_token, -            token_type="bearer", -            user=user_response -        ) -    except HTTPException: -        raise -    except Exception as e: -        logger.error(f"로그인 오류: {str(e)}") +@router.post("/signup") +def signup(site_id: str, nickname: str, password: str, invite_code: str, db: Session = Depends(get_db)): +    """회원가입 엔드포인트""" +    logger.debug(f"[AUTH] Signup attempt for username: {site_id}") +     +    # 아이디 중복 확인 +    existing_user = db.query(User).filter(User.site_id == site_id).first() +    if existing_user:          raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="로그인 처리 중 오류가 발생했습니다" -        ) - -@router.post("/admin/login", response_model=Token) -async def admin_login( -    form_data: AdminLogin, -    db: Session = Depends(get_db), -    auth_service: AuthService = Depends(get_auth_service) -): -    """관리자 로그인""" -    try: -        logger.info(f"관리자 로그인 시도: site_id={form_data.site_id}") -         -        # 관리자 인증 -        user = auth_service.authenticate_admin(form_data.site_id, form_data.password) -        if not user: -            raise HTTPException( -                status_code=status.HTTP_401_UNAUTHORIZED, -                detail="관리자 인증에 실패했습니다", -                headers={"WWW-Authenticate": "Bearer"}, -            ) -             -        # JWT 토큰 생성 -        access_token = auth_service.create_access_token({ -            "sub": user.site_id, -            "user_id": user.id, -            "is_admin": user.is_admin -        }) -         -        # 마지막 로그인 시간 업데이트 -        user.last_login = datetime.utcnow() -        db.commit() -         -        # 응답 데이터 생성 -        user_response = UserResponse( -            id=user.id, -            site_id=user.site_id, -            nickname=user.nickname, -            phone_number=user.phone_number, -            cyber_token_balance=user.cyber_token_balance, -            created_at=user.created_at, -            last_login=user.last_login, -            is_admin=user.is_admin, -            is_active=user.is_active -        ) -         -        logger.info(f"관리자 로그인 성공: user_id={user.id}") -         -        return Token( -            access_token=access_token, -            token_type="bearer", -            user=user_response +            status_code=status.HTTP_400_BAD_REQUEST, +            detail="이미 사용중인 아이디입니다",          ) -    except HTTPException: -        raise -    except Exception as e: -        logger.error(f"관리자 로그인 오류: {str(e)}") +     +    # 닉네임 중복 확인 +    existing_nickname = db.query(User).filter(User.nickname == nickname).first() +    if existing_nickname:          raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="관리자 로그인 처리 중 오류가 발생했습니다" -        ) - -@router.post("/refresh", response_model=Token) -async def refresh_token( -    credentials: HTTPAuthorizationCredentials = Depends(security), -    db: Session = Depends(get_db), -    auth_service: AuthService = Depends(get_auth_service) -): -    """토큰 갱신""" -    logger.info("API: POST /api/auth/refresh - 토큰 갱신 요청") -    try: -        # 현재 토큰에서 사용자 정보 추출 -        token_data = auth_service.verify_token(credentials.credentials) -         -        # 사용자 조회 -        user = db.query(User).filter(User.id == token_data.user_id).first() -        if not user: -            raise HTTPException( -                status_code=status.HTTP_401_UNAUTHORIZED, -                detail="사용자를 찾을 수 없습니다" -            ) -         -        # 새 토큰 생성 -        new_access_token = auth_service.create_access_token({ -            "sub": user.site_id, -            "user_id": user.id, -            "is_admin": user.is_admin -        }) -         -        # 사용자 응답 데이터 생성 -        user_response = UserResponse( -            id=user.id, -            site_id=user.site_id, -            nickname=user.nickname, -            phone_number=user.phone_number, -            cyber_token_balance=user.cyber_token_balance, -            created_at=user.created_at, -            last_login=user.last_login or user.created_at, -            is_admin=user.is_admin, -            is_active=user.is_active -        ) -         -        logger.info(f"토큰 갱신 성공: user_id={user.id}") -         -        return Token( -            access_token=new_access_token, -            token_type="bearer", -            user=user_response +            status_code=status.HTTP_400_BAD_REQUEST, +            detail="이미 사용중인 닉네임입니다",          ) -    except HTTPException: -        raise -    except Exception as e: -        logger.error(f"토큰 갱신 오류: {str(e)}") +     +    # 초대코드 확인 +    invite = db.query(InviteCode).filter(InviteCode.code == invite_code, InviteCode.is_used == False).first() +    if not invite:          raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="토큰 갱신 중 오류가 발생했습니다" +            status_code=status.HTTP_400_BAD_REQUEST, +            detail="유효하지 않은 초대코드입니다",          ) +     +    # 비밀번호 해싱 +    hashed_password = pwd_context.hash(password) +     +    # 사용자 생성 +    new_user = User( +        site_id=site_id, +        nickname=nickname, +        password_hash=hashed_password, +        is_active=True, +    ) +     +    # 초대코드 사용 처리 +    invite.is_used = True +     +    # 데이터베이스 저장 +    db.add(new_user) +    db.commit() +    db.refresh(new_user) +     +    logger.debug(f"[AUTH] Signup successful for user: {new_user.nickname}") +     +    # 자동 로그인을 위한 토큰 생성 +    access_token_expires = timedelta(minutes=settings.jwt_access_token_expire_minutes) +    access_token = create_access_token( +        data={"user_id": new_user.id, "sub": new_user.site_id}, +        expires_delta=access_token_expires, +    ) +     +    return { +        "access_token": access_token, +        "token_type": "bearer", +        "user_id": new_user.id, +        "nickname": new_user.nickname, +    }   -@router.post("/logout") -async def logout( -    credentials: HTTPAuthorizationCredentials = Depends(security), -    auth_service: AuthService = Depends(get_auth_service) -): -    """로그아웃""" -    logger.info("API: POST /api/auth/logout - 로그아웃 요청") -    try: -        # 토큰 검증만 수행 (실제로는 토큰 블랙리스트 등을 구현할 수 있음) -        token_data = auth_service.verify_token(credentials.credentials) -        logger.info(f"로그아웃 성공: user_id={token_data.user_id}") -         -        return {"message": "로그아웃되었습니다"} -    except HTTPException: -        raise -    except Exception as e: -        logger.error(f"로그아웃 오류: {str(e)}") -        raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="로그아웃 처리 중 오류가 발생했습니다" -        ) +@router.get("/me") +def get_me(current_user: User = Depends(get_current_user)): +    """현재 로그인한 사용자 정보 조회""" +    return { +        "user_id": current_user.id, +        "site_id": current_user.site_id, +        "nickname": current_user.nickname, +        "is_admin": current_user.is_admin, +    }
`

### Key differences:
- [ANALYZE] Differences need manual review

### Comparing auth.py vs auth_temp.py
`diff
diff --git "a/cc-webapp\\backend\\app\\routers\\auth.py" "b/cc-webapp\\backend\\app\\routers\\auth_temp.py" index 622c937..e69de29 100644 --- "a/cc-webapp\\backend\\app\\routers\\auth.py" +++ "b/cc-webapp\\backend\\app\\routers\\auth_temp.py" @@ -1,546 +0,0 @@ -"""통합된 인증 API 라우터 - -Casino-Club F2P - 인증 시스# 라우터 정의 -router = APIRouter( -    prefix="/api/auth", -    tags=["authentication"] -) - -def get_auth_service(db: Session = Depends(get_db)) -> AuthService: -    """AuthService 인스턴스 생성""" -    return AuthService(db) - -@router.post("/login", response_model=Token) -async def login( -    form_data: UserLogin, -    auth_service: AuthService = Depends(get_auth_service), -    request: Request = None -): -    """일반 사용자 로그인""" -    user = auth_service.authenticate_user(form_data.site_id, form_data.password) -    if not user: -        raise HTTPException( -            status_code=status.HTTP_401_UNAUTHORIZED, -            detail="Incorrect username or password" -        ) -     -    # 액세스 토큰 생성 -    access_token_data = { -        "sub": str(user.id), -        "site_id": user.site_id, -        "is_admin": user.is_admin -    } -    access_token = auth_service.create_access_token(access_token_data) -     -    # 리프레시 토큰 생성 -    refresh_token_data = { -        "sub": str(user.id), -        "site_id": user.site_id -    } -    refresh_token = auth_service.create_refresh_token(refresh_token_data) -     -    # 응답 -    return { -        "access_token": access_token, -        "refresh_token": refresh_token, -        "token_type": "bearer", -        "user": user -    } - -@router.post("/admin/login", response_model=Token) -async def admin_login( -    form_data: AdminLogin, -    auth_service: AuthService = Depends(get_auth_service), -    request: Request = None -): -    """관리자 로그인""" -    user = auth_service.authenticate_admin(form_data.site_id, form_data.password) -    if not user: -        raise HTTPException( -            status_code=status.HTTP_401_UNAUTHORIZED, -            detail="Incorrect username or password or not admin" -        ) -     -    # 액세스 토큰 생성 -    access_token_data = { -        "sub": str(user.id), -        "site_id": user.site_id, -        "is_admin": True -    } -    access_token = auth_service.create_access_token(access_token_data) -     -    # 리프레시 토큰 생성 -    refresh_token_data = { -        "sub": str(user.id), -        "site_id": user.site_id, -        "is_admin": True -    } -    refresh_token = auth_service.create_refresh_token(refresh_token_data) -     -    # 응답 -    return { -        "access_token": access_token, -        "refresh_token": refresh_token, -        "token_type": "bearer", -        "user": user -    } - -@router.post("/refresh", response_model=Token) -async def refresh_token( -    refresh_request: RefreshTokenRequest, -    auth_service: AuthService = Depends(get_auth_service) -): -    """리프레시 토큰으로 새 액세스 토큰 발급""" -    try: -        # 리프레시 토큰 검증 -        payload = auth_service.verify_refresh_token(refresh_request.refresh_token) -         -        # 새 액세스 토큰 생성 -        access_token_data = { -            "sub": payload["sub"], -            "site_id": payload["site_id"] -        } -        if "is_admin" in payload: -            access_token_data["is_admin"] = payload["is_admin"] -             -        new_access_token = auth_service.create_access_token(access_token_data) -         -        # 유저 정보 조회 -        user_id = int(payload["sub"]) -        user = auth_service.db.query(User).filter(User.id == user_id).first() -        if not user: -            raise HTTPException( -                status_code=status.HTTP_404_NOT_FOUND, -                detail="User not found" -            ) -         -        # 응답 -        return { -            "access_token": new_access_token, -            "refresh_token": refresh_request.refresh_token,  # 기존 리프레시 토큰 유지 -            "token_type": "bearer", -            "user": user -        } -         -    except HTTPException as e: -        raise e -    except Exception as e: -        raise HTTPException( -            status_code=status.HTTP_401_UNAUTHORIZED, -            detail=f"Could not validate refresh token: {str(e)}" -        ) - -@router.post("/logout") -async def logout( -    logout_request: LogoutRequest, -    auth_service: AuthService = Depends(get_auth_service), -    current_user: User = Depends(get_current_user) -): -    """로그아웃 - 토큰 블랙리스트 추가""" -    # 현재 액세스 토큰 블랙리스트에 추가 -    token = auth_service.blacklist_token(logout_request.refresh_token, reason="logout") -    if not token: -        raise HTTPException( -            status_code=status.HTTP_400_BAD_REQUEST, -            detail="Could not blacklist token" -        ) -     -    return {"message": "Successfully logged out"}============================================================================ -기능: -- 초대 코드를 통한 회원가입 -- 아이디/비밀번호 로그인 -- JWT 토큰 관리 (액세스 + 리프레시) -- 세션 관리 및 보안 -- 토큰 블랙리스트 -- 로그아웃 -""" - -import logging -from datetime import datetime, timedelta -from typing import Optional, Dict, Any -from fastapi import APIRouter, Depends, HTTPException, status, Request, Response -from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer, OAuth2PasswordRequestForm -from sqlalchemy.orm import Session - -from ..auth.auth_service import AuthService -from ..database import get_db -from ..schemas.auth import ( -    UserCreate, UserLogin, AdminLogin, UserResponse, Token, -    RefreshTokenRequest, LogoutRequest -) -from ..models.auth_models import User -from ..config import settings -from ..dependencies import get_current_user, get_current_admin_user - -# 로깅 설정 -logger = logging.getLogger(__name__) -logger.setLevel(logging.DEBUG) - -# 콘솔 로그 핸들러 설정 -if not logger.handlers: -    handler = logging.StreamHandler() -    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') -    handler.setFormatter(formatter) -    logger.addHandler(handler) - -# HTTP 보안 스키마 -security = HTTPBearer() - -# 라우터 정의 -router = APIRouter( -    prefix="/api/auth", -    tags=["authentication"] -) - -    def create_access_token(self, data: dict, expires_delta: Optional[timedelta] = None) -> str: -        """JWT 액세스 토큰 생성""" -        try: -            to_encode = data.copy() -            expire = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.jwt_expire_minutes)) -            to_encode.update({"exp": expire}) -            encoded_jwt = jwt.encode(to_encode, settings.jwt_secret_key, algorithm=settings.jwt_algorithm) -            return encoded_jwt -        except Exception as e: -            logger.error(f"토큰 생성 중 오류 발생: {str(e)}") -            raise HTTPException( -                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -                detail="토큰 생성 중 오류가 발생했습니다." -            ) -     -    def create_user(self, user_data: UserCreate) -> User: -        """새로운 사용자 생성""" -        # 초대 코드 확인 -        invite_code = self.db.query(InviteCode).filter( -            InviteCode.code == user_data.invite_code, -            InviteCode.is_active == True -        ).first() -         -        if not invite_code or (invite_code.code != "5858" and invite_code.is_used): -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="유효하지 않은 초대 코드입니다." -            ) -             -        # 비밀번호 유효성 검사 -        if len(user_data.password) < 4: -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="비밀번호는 4자리 이상이어야 합니다." -            ) -             -        # 중복 검사 -        if self.db.query(User).filter(User.site_id == user_data.site_id).first(): -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="이미 사용 중인 아이디입니다." -            ) -        if self.db.query(User).filter(User.nickname == user_data.nickname).first(): -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="이미 사용 중인 닉네임입니다." -            ) -        if self.db.query(User).filter(User.phone_number == user_data.phone_number).first(): -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="이미 등록된 전화번호입니다." -            ) -             -        # 사용자 생성 -        hashed_password = self.pwd_context.hash(user_data.password) -        user = User( -            site_id=user_data.site_id, -            password_hash=hashed_password, -            nickname=user_data.nickname, -            phone_number=user_data.phone_number, -            invite_code=user_data.invite_code -        ) -         -        try: -            self.db.add(user) -            # 초대 코드가 5858이 아닌 경우에만 used 처리 -            if invite_code.code != "5858": -                invite_code.is_used = True -                invite_code.used_by_user_id = user.id -                invite_code.used_at = datetime.utcnow() -            self.db.commit() -            self.db.refresh(user) -            return user -        except Exception as e: -            self.db.rollback() -            logger.error(f"회원가입 처리 중 오류 발생: {str(e)}") -            raise HTTPException( -                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -                detail="회원가입 처리 중 오류가 발생했습니다." -            ) - -# OAuth2 schema -oauth2_scheme = HTTPBearer() - -# Configuration values -JWT_EXPIRE_MINUTES = settings.jwt_expire_minutes -INITIAL_CYBER_TOKENS = getattr(settings, 'initial_cyber_tokens', 200) - -# 라우터 설정 -router = APIRouter( -    prefix="/api/auth", -    tags=["Authentication"], -    responses={401: {"description": "인증 오류"}} -) - -# 인증 서비스 의존성 -def get_auth_service(db: Session = Depends(get_db)) -> AuthService: -    return AuthService(db) - -@router.post("/signup", response_model=Token) -async def signup( -    data: UserCreate, -    db: Session = Depends(get_db), -    auth_service: AuthService = Depends(get_auth_service) -): -    """사용자 등록 (회원가입) -     -    - site_id와 nickname을 이용한 회원가입 -    - 비밀번호는 4글자 이상 -    - 초대 코드 '5858' 사용 -    """ -    try: -        logger.info(f"회원가입 시도: site_id={data.site_id}, nickname={data.nickname}") -         -        # 비밀번호 검증 -        if len(data.password) < 4: -            raise HTTPException( -                status_code=status.HTTP_400_BAD_REQUEST, -                detail="비밀번호는 4글자 이상이어야 합니다" -            ) -         -        # 사용자 생성 -        user = auth_service.create_user(data) -         -        # JWT 토큰 생성 -        access_token = auth_service.create_access_token({ -            "sub": user.site_id, -            "user_id": user.id, -            "is_admin": user.is_admin -        }) -         -        # 응답 데이터 생성 -        user_response = UserResponse( -            id=user.id, -            site_id=user.site_id, -            nickname=user.nickname, -            phone_number=user.phone_number, -            cyber_token_balance=user.cyber_token_balance, -            created_at=user.created_at, -            last_login=user.last_login or user.created_at,  # last_login이 None이면 created_at 사용 -            is_admin=user.is_admin, -            is_active=user.is_active -        ) -         -        logger.info(f"회원가입 성공: user_id={user.id}") -         -        return Token( -            access_token=access_token, -            token_type="bearer", -            user=user_response -        ) -    except HTTPException: -        raise -    except Exception as e: -        logger.error(f"회원가입 오류: {str(e)}") -        raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="회원가입 처리 중 오류가 발생했습니다" -        ) - -# 로그인 라우터 수정 - 올바른 응답 포맷으로 변경 -@router.post("/login", response_model=Token) -async def login( -    form_data: OAuth2PasswordRequestForm = Depends(), -    db: Session = Depends(get_db), -    auth_service: AuthService = Depends(get_auth_service) -): -    """사용자 로그인""" -    try: -        # 사용자 인증 -        user = auth_service.authenticate_user(form_data.username, form_data.password) -        if not user: -            raise HTTPException( -                status_code=status.HTTP_401_UNAUTHORIZED, -                detail="아이디 또는 비밀번호가 잘못되었습니다", -                headers={"WWW-Authenticate": "Bearer"}, -            ) -             -        # JWT 토큰 생성 -        access_token = auth_service.create_access_token({ -            "sub": user.site_id, -            "user_id": user.id, -            "is_admin": user.is_admin -        }) -         -        # 마지막 로그인 시간 업데이트 -        user.last_login = datetime.utcnow() -        db.commit() -         -        # 응답 데이터 생성 -        user_response = UserResponse( -            id=user.id, -            site_id=user.site_id, -            nickname=user.nickname, -            phone_number=user.phone_number, -            cyber_token_balance=user.cyber_token_balance, -            created_at=user.created_at, -            last_login=user.last_login, -            is_admin=user.is_admin, -            is_active=user.is_active -        ) -         -        return Token( -            access_token=access_token, -            token_type="bearer", -            user=user_response -        ) -    except HTTPException: -        raise -    except Exception as e: -        logger.error(f"로그인 오류: {str(e)}") -        raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="로그인 처리 중 오류가 발생했습니다" -        ) - -@router.post("/admin/login", response_model=Token) -async def admin_login( -    form_data: AdminLogin, -    db: Session = Depends(get_db), -    auth_service: AuthService = Depends(get_auth_service) -): -    """관리자 로그인""" -    try: -        logger.info(f"관리자 로그인 시도: site_id={form_data.site_id}") -         -        # 관리자 인증 -        user = auth_service.authenticate_admin(form_data.site_id, form_data.password) -        if not user: -            raise HTTPException( -                status_code=status.HTTP_401_UNAUTHORIZED, -                detail="관리자 인증에 실패했습니다", -                headers={"WWW-Authenticate": "Bearer"}, -            ) -             -        # JWT 토큰 생성 -        access_token = auth_service.create_access_token({ -            "sub": user.site_id, -            "user_id": user.id, -            "is_admin": user.is_admin -        }) -         -        # 마지막 로그인 시간 업데이트 -        user.last_login = datetime.utcnow() -        db.commit() -         -        # 응답 데이터 생성 -        user_response = UserResponse( -            id=user.id, -            site_id=user.site_id, -            nickname=user.nickname, -            phone_number=user.phone_number, -            cyber_token_balance=user.cyber_token_balance, -            created_at=user.created_at, -            last_login=user.last_login, -            is_admin=user.is_admin, -            is_active=user.is_active -        ) -         -        logger.info(f"관리자 로그인 성공: user_id={user.id}") -         -        return Token( -            access_token=access_token, -            token_type="bearer", -            user=user_response -        ) -    except HTTPException: -        raise -    except Exception as e: -        logger.error(f"관리자 로그인 오류: {str(e)}") -        raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="관리자 로그인 처리 중 오류가 발생했습니다" -        ) - -@router.post("/refresh", response_model=Token) -async def refresh_token( -    credentials: HTTPAuthorizationCredentials = Depends(security), -    db: Session = Depends(get_db), -    auth_service: AuthService = Depends(get_auth_service) -): -    """토큰 갱신""" -    logger.info("API: POST /api/auth/refresh - 토큰 갱신 요청") -    try: -        # 현재 토큰에서 사용자 정보 추출 -        token_data = auth_service.verify_token(credentials.credentials) -         -        # 사용자 조회 -        user = db.query(User).filter(User.id == token_data.user_id).first() -        if not user: -            raise HTTPException( -                status_code=status.HTTP_401_UNAUTHORIZED, -                detail="사용자를 찾을 수 없습니다" -            ) -         -        # 새 토큰 생성 -        new_access_token = auth_service.create_access_token({ -            "sub": user.site_id, -            "user_id": user.id, -            "is_admin": user.is_admin -        }) -         -        # 사용자 응답 데이터 생성 -        user_response = UserResponse( -            id=user.id, -            site_id=user.site_id, -            nickname=user.nickname, -            phone_number=user.phone_number, -            cyber_token_balance=user.cyber_token_balance, -            created_at=user.created_at, -            last_login=user.last_login or user.created_at, -            is_admin=user.is_admin, -            is_active=user.is_active -        ) -         -        logger.info(f"토큰 갱신 성공: user_id={user.id}") -         -        return Token( -            access_token=new_access_token, -            token_type="bearer", -            user=user_response -        ) -    except HTTPException: -        raise -    except Exception as e: -        logger.error(f"토큰 갱신 오류: {str(e)}") -        raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="토큰 갱신 중 오류가 발생했습니다" -        ) - -@router.post("/logout") -async def logout( -    credentials: HTTPAuthorizationCredentials = Depends(security), -    auth_service: AuthService = Depends(get_auth_service) -): -    """로그아웃""" -    logger.info("API: POST /api/auth/logout - 로그아웃 요청") -    try: -        # 토큰 검증만 수행 (실제로는 토큰 블랙리스트 등을 구현할 수 있음) -        token_data = auth_service.verify_token(credentials.credentials) -        logger.info(f"로그아웃 성공: user_id={token_data.user_id}") -         -        return {"message": "로그아웃되었습니다"} -    except HTTPException: -        raise -    except Exception as e: -        logger.error(f"로그아웃 오류: {str(e)}") -        raise HTTPException( -            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, -            detail="로그아웃 처리 중 오류가 발생했습니다" -        )
`

### Key differences:
- [ANALYZE] Differences need manual review

## Games Files Comparison

### Comparing games.py vs games_fixed.py
`diff
diff --git "a/cc-webapp\\backend\\app\\routers\\games.py" "b/cc-webapp\\backend\\app\\routers\\games_fixed.py" index 78bbc93..02f7c83 100644 --- "a/cc-webapp\\backend\\app\\routers\\games.py" +++ "b/cc-webapp\\backend\\app\\routers\\games_fixed.py" @@ -34,13 +34,24 @@ async def get_games_list(      result = []            for game in games: -        result.append({ -            "id": game.id, +        # 모든 필수 필드가 있는 딕셔너리 생성 +        game_dict = { +            "id": str(game.id),              "name": game.name,              "description": game.description, -            "game_type": game.game_type, -            "is_active": game.is_active -        }) +            "type": game.game_type, +            "image_url": getattr(game, 'image_url', f"/assets/games/{game.game_type}.png"), +            "is_active": game.is_active, +            "daily_limit": None, +            "playCount": 0, +            "bestScore": 0, +            "canPlay": True, +            "cooldown_remaining": None, +            "requires_vip_tier": None +        } +        # GameListResponse 모델에 전달 +        game_response = GameListResponse(**game_dict) +        result.append(game_response)            return result   @@ -94,12 +105,18 @@ async def spin_slot(      db.add(user_action)      db.commit()       -    return { -        'reels': reels, -        'win_amount': win_amount, -        'is_jackpot': reels[0] == '7️⃣' and reels[0] == reels[1] == reels[2], -        'balance': new_balance -    } +    # SlotSpinResponse 객체 생성 (이중 리스트로 reels 설정) +    return SlotSpinResponse( +        success=True, +        reels=[reels],  # 이중 리스트로 감싸기 +        win_amount=win_amount, +        win_lines=[], +        multiplier=1.0, +        is_jackpot=reels[0] == '7️⃣' and reels[0] == reels[1] == reels[2], +        free_spins_awarded=0, +        message='슬롯 게임 결과입니다.', +        balance=new_balance +    )    # 가위바위보 엔드포인트  @router.post("/rps/play", response_model=RPSPlayResponse) @@ -162,13 +179,16 @@ async def play_rps(      db.add(user_action)      db.commit()       -    return { -        'user_choice': user_choice, -        'ai_choice': ai_choice, -        'result': result, -        'win_amount': win_amount, -        'balance': new_balance -    } +    return RPSPlayResponse( +        success=True, +        player_choice=user_choice, +        computer_choice=ai_choice, +        result=result, +        win_amount=win_amount, +        message=f'결과: {result}', +        balance=new_balance, +        streak=1 +    )    # 가챠 엔드포인트  @router.post("/gacha/pull", response_model=GachaPullResponse) @@ -221,11 +241,14 @@ async def pull_gacha(      db.add(user_action)      db.commit()       -    return { -        'items': items, -        'total_value': sum(item['value'] for item in items), -        'balance': new_balance -    } +    return GachaPullResponse( +        success=True, +        items=items, +        rare_item_count=sum(1 for item in items if item['rarity'] == 'rare'), +        ultra_rare_item_count=sum(1 for item in items if item['rarity'] in ['epic', 'legendary']), +        message='가챠 뽑기 결과입니다.', +        currency_balance={'cyber_token': new_balance} +    )    # 크래시 게임 엔드포인트  @router.post("/crash/bet", response_model=CrashBetResponse) @@ -280,11 +303,12 @@ async def place_crash_bet(      db.add(user_action)      db.commit()       -    return { -        'game_id': game_id, -        'bet_amount': bet_amount, -        'auto_cashout_multiplier': auto_cashout_multiplier, -        'multiplier': round(multiplier, 2), -        'win_amount': win_amount, -        'balance': new_balance -    } +    return CrashBetResponse( +        success=True, +        game_id=game_id, +        bet_amount=bet_amount, +        potential_win=int(bet_amount * multiplier) if win_amount == 0 else win_amount, +        max_multiplier=round(multiplier, 2), +        message='크래시 게임 베팅이 완료되었습니다.', +        balance=new_balance +    )
`

### Key differences:
- [ANALYZE] Differences need manual review

### Comparing games.py vs games_direct.py
`diff
diff --git "a/cc-webapp\\backend\\app\\routers\\games.py" "b/cc-webapp\\backend\\app\\routers\\games_direct.py" index 78bbc93..60cf02c 100644 --- "a/cc-webapp\\backend\\app\\routers\\games.py" +++ "b/cc-webapp\\backend\\app\\routers\\games_direct.py" @@ -1,8 +1,9 @@ -"""Game Collection API Endpoints""" +"""Game Collection API Endpoints (Updated)"""  import logging -from fastapi import APIRouter, Depends, HTTPException +from fastapi import APIRouter, Depends, HTTPException, Response  from sqlalchemy.orm import Session  import random +import json  from typing import List, Optional, Dict, Any  from datetime import datetime  from ..database import get_db @@ -22,37 +23,47 @@ from ..schemas.game_schemas import (  logger = logging.getLogger(__name__)  router = APIRouter(prefix="/api/games", tags=["Games"])   -@router.get("/", response_model=List[GameListResponse]) +@router.get("/")  async def get_games_list(      current_user: User = Depends(get_current_user),      db: Session = Depends(get_db)  ):      """ -    게임 목록 조회 +    게임 목록 조회 (직접 JSON 반환)      """      games = db.query(Game).filter(Game.is_active == True).all()      result = []            for game in games: -        result.append({ -            "id": game.id, +        # 직접 JSON 형식 준비 +        game_data = { +            "id": str(game.id),              "name": game.name,              "description": game.description, -            "game_type": game.game_type, -            "is_active": game.is_active -        }) -     -    return result +            "type": game.game_type, +            "image_url": getattr(game, 'image_url', f"/assets/games/{game.game_type}.png"), +            "is_active": game.is_active, +            "daily_limit": None, +            "playCount": 0, +            "bestScore": 0, +            "canPlay": True, +            "cooldown_remaining": None, +            "requires_vip_tier": None +        } +        result.append(game_data) +     +    # 직접 JSON 반환 +    return Response(content=json.dumps(result), media_type="application/json")    # 슬롯 게임 엔드포인트 -@router.post("/slot/spin", response_model=SlotSpinResponse) +@router.post("/slot/spin")  async def spin_slot(      request: SlotSpinRequest,      current_user: User = Depends(get_current_user),      db: Session = Depends(get_db)  ):      """ -    슬롯머신 스핀 +    슬롯머신 스핀 (직접 JSON 반환)      """      bet_amount = request.bet_amount       @@ -94,22 +105,30 @@ async def spin_slot(      db.add(user_action)      db.commit()       -    return { -        'reels': reels, -        'win_amount': win_amount, -        'is_jackpot': reels[0] == '7️⃣' and reels[0] == reels[1] == reels[2], -        'balance': new_balance +    # 직접 JSON 반환 +    response_data = { +        "success": True, +        "reels": [reels], +        "win_amount": win_amount, +        "win_lines": [], +        "multiplier": 1.0, +        "is_jackpot": reels[0] == '7️⃣' and reels[0] == reels[1] == reels[2], +        "free_spins_awarded": 0, +        "message": "슬롯 게임 결과입니다.", +        "balance": new_balance      } +     +    return Response(content=json.dumps(response_data), media_type="application/json")    # 가위바위보 엔드포인트 -@router.post("/rps/play", response_model=RPSPlayResponse) +@router.post("/rps/play")  async def play_rps(      request: RPSPlayRequest,      current_user: User = Depends(get_current_user),      db: Session = Depends(get_db)  ):      """ -    가위바위보 플레이 +    가위바위보 플레이 (직접 JSON 반환)      """      user_choice = request.choice      bet_amount = request.bet_amount @@ -162,23 +181,29 @@ async def play_rps(      db.add(user_action)      db.commit()       -    return { -        'user_choice': user_choice, -        'ai_choice': ai_choice, -        'result': result, -        'win_amount': win_amount, -        'balance': new_balance +    # 직접 JSON 반환 +    response_data = { +        "success": True, +        "player_choice": user_choice, +        "computer_choice": ai_choice, +        "result": result, +        "win_amount": win_amount, +        "message": f"결과: {result}", +        "balance": new_balance, +        "streak": 1      } +     +    return Response(content=json.dumps(response_data), media_type="application/json")    # 가챠 엔드포인트 -@router.post("/gacha/pull", response_model=GachaPullResponse) +@router.post("/gacha/pull")  async def pull_gacha(      request: GachaPullRequest,      current_user: User = Depends(get_current_user),      db: Session = Depends(get_db)  ):      """ -    가챠 뽑기 +    가챠 뽑기 (직접 JSON 반환)      """      pull_count = request.pull_count      cost_per_pull = 300 @@ -221,21 +246,27 @@ async def pull_gacha(      db.add(user_action)      db.commit()       -    return { -        'items': items, -        'total_value': sum(item['value'] for item in items), -        'balance': new_balance +    # 직접 JSON 반환 +    response_data = { +        "success": True, +        "items": items, +        "rare_item_count": sum(1 for item in items if item['rarity'] == 'rare'), +        "ultra_rare_item_count": sum(1 for item in items if item['rarity'] in ['epic', 'legendary']), +        "message": "가챠 뽑기 결과입니다.", +        "currency_balance": {"cyber_token": new_balance}      } +     +    return Response(content=json.dumps(response_data), media_type="application/json")    # 크래시 게임 엔드포인트 -@router.post("/crash/bet", response_model=CrashBetResponse) +@router.post("/crash/bet")  async def place_crash_bet(      request: CrashBetRequest,      current_user: User = Depends(get_current_user),      db: Session = Depends(get_db)  ):      """ -    크래시 게임 베팅 +    크래시 게임 베팅 (직접 JSON 반환)      """      bet_amount = request.bet_amount      auto_cashout_multiplier = request.auto_cashout_multiplier @@ -280,11 +311,15 @@ async def place_crash_bet(      db.add(user_action)      db.commit()       -    return { -        'game_id': game_id, -        'bet_amount': bet_amount, -        'auto_cashout_multiplier': auto_cashout_multiplier, -        'multiplier': round(multiplier, 2), -        'win_amount': win_amount, -        'balance': new_balance +    # 직접 JSON 반환 +    response_data = { +        "success": True, +        "game_id": game_id, +        "bet_amount": bet_amount, +        "potential_win": int(bet_amount * multiplier) if win_amount == 0 else win_amount, +        "max_multiplier": round(multiplier, 2), +        "message": "크래시 게임 베팅이 완료되었습니다.", +        "balance": new_balance      } +     +    return Response(content=json.dumps(response_data), media_type="application/json")
`

### Key differences:
- [ANALYZE] Differences need manual review

## Docker Files Comparison

### Comparing docker-compose.yml vs docker-compose.simple.yml
`diff
diff --git a/docker-compose.yml b/docker-compose.simple.yml index d2ff6fe..c12dc6b 100644 --- a/docker-compose.yml +++ b/docker-compose.simple.yml @@ -5,37 +5,37 @@ services:      build:        context: ./cc-webapp/backend        dockerfile: Dockerfile -    container_name: cc_backend +    container_name: cc_backend_simple      environment:        - PYTHONPATH=/app -      - POSTGRES_SERVER=${POSTGRES_SERVER:-postgres} -      - POSTGRES_USER=${POSTGRES_USER:-cc_user} -      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-cc_password} -      - POSTGRES_DB=${POSTGRES_DB:-cc_webapp} -      - REDIS_HOST=${REDIS_HOST:-redis} -      - REDIS_PORT=${REDIS_PORT:-6379} -      - JWT_SECRET_KEY=${JWT_SECRET_KEY:-secret_key_for_development_only} +      - POSTGRES_SERVER=postgres_simple +      - POSTGRES_USER=cc_user +      - POSTGRES_PASSWORD=cc_password +      - POSTGRES_DB=cc_webapp +      - REDIS_HOST=redis +      - REDIS_PORT=6379 +      - JWT_SECRET_KEY=simple_secret_key_for_development      volumes:        - ./cc-webapp/backend:/app -      - ./logs/backend:/app/logs:rw +      - ./logs/backend:/app/logs      ports:        - "8000:8000"      depends_on:        - postgres -      - redis      networks:        - ccnet +    command: ["sh", "-c", "uvicorn app.main_simple:app --host 0.0.0.0 --port 8000 --reload"]      frontend:      build:        context: ./cc-webapp/frontend        dockerfile: Dockerfile.dev -    container_name: cc_frontend +    container_name: cc_frontend_simple      environment: -      - NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL:-http://localhost:8000} +      - NEXT_PUBLIC_API_URL=http://localhost:8000      volumes:        - ./cc-webapp/frontend:/app -      - ./logs/frontend:/app/logs:rw +      - ./logs/frontend:/app/logs      ports:        - "3000:3000"      depends_on: @@ -45,26 +45,34 @@ services:      postgres:      image: postgres:14 -    container_name: cc_postgres +    container_name: postgres_simple      environment: -      - POSTGRES_USER=${POSTGRES_USER:-cc_user} -      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-cc_password} -      - POSTGRES_DB=${POSTGRES_DB:-cc_webapp} +      - POSTGRES_USER=cc_user +      - POSTGRES_PASSWORD=cc_password +      - POSTGRES_DB=cc_webapp      volumes: -      - ./data/postgres:/var/lib/postgresql/data:rw -      - ./logs/postgres:/var/log/postgresql:rw +      - ./data/postgres_simple:/var/lib/postgresql/data      ports:        - "5432:5432"      networks:        - ccnet   -  redis: -    image: redis:7 -    container_name: cc_redis -    command: redis-server --requirepass ${REDIS_PASSWORD:-redis_password} +  # pgAdmin 개발 도구 추가 +  pgadmin: +    image: dpage/pgadmin4:latest +    container_name: cc_pgadmin +    environment: +      - PGADMIN_DEFAULT_EMAIL=admin@casino-club.local +      - PGADMIN_DEFAULT_PASSWORD=admin123 +    volumes: +      - ./data/pgadmin:/var/lib/pgadmin +    ports: +      - "5050:80" +    depends_on: +      - postgres      networks:        - ccnet    networks:    ccnet: -    driver: bridge \ No newline at end of file +    driver: bridge
`

### Key differences:
- [ANALYZE] Differences need manual review

### Comparing docker-compose.yml vs docker-compose.basic.yml
`diff
diff --git a/docker-compose.yml b/docker-compose.basic.yml index d2ff6fe..7a4ca5e 100644 --- a/docker-compose.yml +++ b/docker-compose.basic.yml @@ -1,70 +1,63 @@  version: "3.8"    services: -  backend: -    build: +  db: +    image: postgres:14 +    container_name: cc_db +    environment: +      - POSTGRES_USER=cc_user +      - POSTGRES_PASSWORD=cc_password +      - POSTGRES_DB=cc_webapp +    volumes: +      - ./data/db:/var/lib/postgresql/data +    ports: +      - "5432:5432" +    networks: +      - cc_network +    healthcheck: +      test: ["CMD-SHELL", "pg_isready -U cc_user -d cc_webapp"] +      interval: 10s +      timeout: 5s +      retries: 5 + +  api: +    build:         context: ./cc-webapp/backend        dockerfile: Dockerfile -    container_name: cc_backend +    container_name: cc_api      environment:        - PYTHONPATH=/app -      - POSTGRES_SERVER=${POSTGRES_SERVER:-postgres} -      - POSTGRES_USER=${POSTGRES_USER:-cc_user} -      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-cc_password} -      - POSTGRES_DB=${POSTGRES_DB:-cc_webapp} -      - REDIS_HOST=${REDIS_HOST:-redis} -      - REDIS_PORT=${REDIS_PORT:-6379} -      - JWT_SECRET_KEY=${JWT_SECRET_KEY:-secret_key_for_development_only} +      - DATABASE_URL=postgresql://cc_user:cc_password@db/cc_webapp +      - JWT_SECRET_KEY=dev_secret_key      volumes:        - ./cc-webapp/backend:/app -      - ./logs/backend:/app/logs:rw +      - ./logs/backend:/app/logs      ports:        - "8000:8000"      depends_on: -      - postgres -      - redis +      db: +        condition: service_healthy      networks: -      - ccnet +      - cc_network +    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload   -  frontend: +  web:      build:        context: ./cc-webapp/frontend        dockerfile: Dockerfile.dev -    container_name: cc_frontend +    container_name: cc_web      environment: -      - NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL:-http://localhost:8000} +      - NEXT_PUBLIC_API_URL=http://localhost:8000      volumes:        - ./cc-webapp/frontend:/app -      - ./logs/frontend:/app/logs:rw +      - ./logs/frontend:/app/logs      ports:        - "3000:3000"      depends_on: -      - backend -    networks: -      - ccnet - -  postgres: -    image: postgres:14 -    container_name: cc_postgres -    environment: -      - POSTGRES_USER=${POSTGRES_USER:-cc_user} -      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-cc_password} -      - POSTGRES_DB=${POSTGRES_DB:-cc_webapp} -    volumes: -      - ./data/postgres:/var/lib/postgresql/data:rw -      - ./logs/postgres:/var/log/postgresql:rw -    ports: -      - "5432:5432" -    networks: -      - ccnet - -  redis: -    image: redis:7 -    container_name: cc_redis -    command: redis-server --requirepass ${REDIS_PASSWORD:-redis_password} +      - api      networks: -      - ccnet +      - cc_network    networks: -  ccnet: -    driver: bridge \ No newline at end of file +  cc_network: +    driver: bridge
`

### Key differences:
- [ANALYZE] Differences need manual review

### Comparing docker-compose.yml vs docker-compose.standalone.yml
`diff
diff --git a/docker-compose.yml b/docker-compose.standalone.yml index d2ff6fe..d9bf9d0 100644 --- a/docker-compose.yml +++ b/docker-compose.standalone.yml @@ -1,70 +1,86 @@  version: "3.8"    services: -  backend: +  backend_standalone:      build:        context: ./cc-webapp/backend -      dockerfile: Dockerfile -    container_name: cc_backend +      dockerfile: Dockerfile.standalone +    container_name: cc_backend_standalone      environment:        - PYTHONPATH=/app -      - POSTGRES_SERVER=${POSTGRES_SERVER:-postgres} +      - POSTGRES_SERVER=${POSTGRES_SERVER:-postgres_standalone}        - POSTGRES_USER=${POSTGRES_USER:-cc_user}        - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-cc_password}        - POSTGRES_DB=${POSTGRES_DB:-cc_webapp} -      - REDIS_HOST=${REDIS_HOST:-redis} +      - REDIS_HOST=${REDIS_HOST:-redis_standalone}        - REDIS_PORT=${REDIS_PORT:-6379}        - JWT_SECRET_KEY=${JWT_SECRET_KEY:-secret_key_for_development_only} +      - DEBUG=true      volumes:        - ./cc-webapp/backend:/app -      - ./logs/backend:/app/logs:rw +      - ./logs/backend_standalone:/app/logs:rw      ports: -      - "8000:8000" +      - "8001:8000"  # 다른 포트 사용      depends_on: -      - postgres -      - redis +      - postgres_standalone +      - redis_standalone      networks: -      - ccnet +      - ccnet_standalone      frontend:      build:        context: ./cc-webapp/frontend        dockerfile: Dockerfile.dev -    container_name: cc_frontend +    container_name: cc_frontend_standalone      environment: -      - NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL:-http://localhost:8000} +      - NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL:-http://localhost:8001}      volumes:        - ./cc-webapp/frontend:/app -      - ./logs/frontend:/app/logs:rw +      - ./logs/frontend_standalone:/app/logs:rw      ports: -      - "3000:3000" +      - "3001:3000"  # 다른 포트 사용      depends_on: -      - backend +      - backend_standalone      networks: -      - ccnet +      - ccnet_standalone   -  postgres: +  postgres_standalone:      image: postgres:14 -    container_name: cc_postgres +    container_name: cc_postgres_standalone      environment:        - POSTGRES_USER=${POSTGRES_USER:-cc_user}        - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-cc_password}        - POSTGRES_DB=${POSTGRES_DB:-cc_webapp}      volumes: -      - ./data/postgres:/var/lib/postgresql/data:rw -      - ./logs/postgres:/var/log/postgresql:rw +      - ./data/postgres_standalone:/var/lib/postgresql/data:rw +      - ./logs/postgres_standalone:/var/log/postgresql:rw      ports: -      - "5432:5432" +      - "5433:5432"  # 다른 포트 사용      networks: -      - ccnet +      - ccnet_standalone   -  redis: +  redis_standalone:      image: redis:7 -    container_name: cc_redis +    container_name: cc_redis_standalone      command: redis-server --requirepass ${REDIS_PASSWORD:-redis_password} +    ports: +      - "6380:6379"  # 다른 포트 사용 +    networks: +      - ccnet_standalone + +  pgadmin: +    image: dpage/pgadmin4 +    container_name: cc_pgadmin_standalone +    environment: +      - PGADMIN_DEFAULT_EMAIL=${PGADMIN_EMAIL:-admin@casino-club.local} +      - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_PASSWORD:-admin123} +    ports: +      - "5050:80" +    depends_on: +      - postgres_standalone      networks: -      - ccnet +      - ccnet_standalone    networks: -  ccnet: -    driver: bridge \ No newline at end of file +  ccnet_standalone: +    driver: bridge
`

### Key differences:
- [ANALYZE] Differences need manual review
