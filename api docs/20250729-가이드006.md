## 사용자 여정 4: 전환 및 수익화 – 상점/프리미엄 잼 구매 API (2025-08-14)

목표
- 상점 프리미엄 젬 구매 플로우를 풀스택으로 구현하고, 다양한 시나리오 및 실패 케이스까지 검증합니다.

구현 사항
- 엔드포인트
  - GET /api/shop/catalog: 카탈로그 조회(가격/할인/필요 등급 포함)
  - POST /api/shop/buy: 프리미엄 젬 실결제 흐름(모의 게이트웨이) → 젬 지급/액션 로그
- 주요 컴포넌트
  - app/services/catalog_service.py: 인메모리 카탈로그 + 할인 정책 계산(compute_price_cents)
  - app/services/payment_gateway.py: 모의 결제 게이트웨이(authorize→capture)
  - app/routers/shop.py: 랭크 자격검사(VIP 등), 가격 계산, 결제, 젬 지급(TokenService), UserAction 거래 로그 기록
  - app/core/config.py: kafka_bootstrap_servers(소문자) 별칭 추가로 런타임 오류 해결

검증 체크리스트
- [x] 상품 카탈로그 관리: SKU/이름/가격/젬/할인/필요 등급 노출
- [x] 가격 정책 및 할인 시스템: 할인율 및 종료시각에 따라 총액 계산
- [x] 구매 전 검증(자격): VIP 전용 상품에 일반 사용자가 접근 시 403
- [x] 결제 게이트웨이 연동: authorize 실패/성공, capture 실패/성공 처리
- [x] 보상 지급: cyber_token_balance 증액
- [x] 거래 로그: UserAction(action_type=SHOP_BUY) 및 charge_id 기록

### 한정 패키지 API (Limited Packages) — 2025-08-14

목표
- 기간/수량/사용자 제한이 있는 한정 패키지를 실결제로 구매할 수 있게 하고, 재고/제한/만료를 엄격히 통제합니다.

엔드포인트
- GET /api/shop/limited/catalog: 활성 패키지 목록(남은 재고·사용자별 잔여 포함)
- POST /api/shop/limited/buy: 한정 패키지 구매(결제→젬지급→행동로그, 재고/제한/롤백)

구성 요소
- app/services/limited_package_service.py: 인메모리 카탈로그 + Redis 재고/사용자 카운터(예약/해제/확정)
- app/routers/shop.py: 패키지 유효기간/활성화, per-user limit, 재고 확인 후 결제/지급/로그, 프로모션 코드(초기형) 반영
- app/schemas/limited_package.py: 출력/구매/영수증 스키마(영수증 DB 보관은 스코프 아웃)

검증 체크리스트(이모지)
- [✅] 시간 제한 패키지 스케줄링(시작/종료, is_active)
- [✅] 수량 제한 재고 관리(예약 실패 409, 결제 실패 시 예약 해제)
- [✅] 사용자별 구매 제한(per_user_limit, 카운터 확정)
- [✅] 패키지 내용물 관리(지급 젬 수량 고정·가변 지원)
- [✅] 프로모션 코드 시스템(MVP: 고정 맵 기반 할인)
- [✅] 긴급 패키지 비활성화 기능(is_active 토글)

테스트
- backend/app/tests/test_shop_limited.py 추가: 카탈로그 노출, 해피패스, per-user 제한, 재고 부족 409, 만료/비활성 403, 결제 실패 예약 해제, 프로모션 코드 할인 검증
- 결과: 컨테이너 내부 pytest 전부 통과(상점 기존 테스트 포함)

OpenAPI 동기화
- 컨테이너 내부에서 재수출 완료: `python -m app.export_openapi` → `backend/current_openapi.json` 갱신

변경 요약
- 한정 패키지 구매 흐름을 Redis 재고/사용자 제한과 결제/지급/행동로그까지 일관되게 구현. 프로모션 코드(초기형) 지원.

다음 단계
- 프런트 UI: 카탈로그/잔여/할인/비활성 상태 표시 및 구매 플로우 연결
- 어드민: 패키지/재고/기간/프로모션 코드 CRUD 및 모니터링
- 분석: BUY_PACKAGE 액션 Kafka 발행 및 OLAP 적재 지표화

빠른 테스트 방법(컨테이너 내부)
- 카탈로그 확인
  - PowerShell
    ```powershell
    Invoke-RestMethod -Uri "http://localhost:8000/api/shop/catalog"
    ```
- 구매 시도(일반 상품)
  - 예: user_id=1, product_id=1001, quantity=2
    ```powershell
    $body = @{ user_id = 1; product_id = 1001; quantity = 2 } | ConvertTo-Json
    Invoke-RestMethod -Method Post -Uri "http://localhost:8000/api/shop/buy" -ContentType 'application/json' -Body $body
    ```
- VIP 가드 확인(403 기대)
    ```powershell
    $body = @{ user_id = 1; product_id = 1004 } | ConvertTo-Json
    try { Invoke-RestMethod -Method Post -Uri "http://localhost:8000/api/shop/buy" -ContentType 'application/json' -Body $body } catch { $_.Exception.Response.StatusCode }
    ```

Pytest(백엔드 컨테이너)
- 선택 실행: /api/shop/buy 관련 테스트
  ```powershell
  docker exec cc_backend_local pytest -q app/tests/test_shop_buy.py
  ```
- 포함 검증 내용: 해피패스(200/젬지급/잔액증가/charge_id), VIP 가드(403), 결제 실패 경로, 카탈로그 구조

OpenAPI 동기화
- 컨테이너 내부에서 스키마 재수출 후 프론트/문서 동기화
  ```powershell
  docker exec cc_backend_local python -m app.export_openapi
  ```

비고
- 결제는 모의 게이트웨이이며, 성공/실패 확률은 테스트 안정화를 위해 시드로 제어 가능합니다(random.seed).
- 카탈로그는 인메모리이며, 이후 DB/어드민 CRUD로 확장 가능합니다.
- 영수증(Reward/UserReward 기반 증빙) 기능은 스코프 아웃되었습니다. 추후 필요 시 재도입 검토.

변경 요약
- /api/shop/catalog, /api/shop/buy 완성. 결제→지급→로그까지 일관 흐름 구현. 설정 오류(kafka_bootstrap_servers) 해결.

검증 결과
- 백엔드 헬스 200. app/tests/test_shop_buy.py 4개 테스트 PASS. OpenAPI 재수출 완료.

다음 단계
- 프런트 상점 UI와 연동(가격/할인/구매 결과 토스트).
- 카탈로그 DB화 및 어드민 관리 UI 추가.
- 결제 실패 재시도/중복 결제 방지/멱등키 도입 검토.

남은 과제(체크박스)
- [ ] 프런트 연동: 카탈로그/할인 표시, 구매 플로우, 결과 토스트 처리
- [ ] 카탈로그 DB/어드민 CRUD: 상품/할인 기간/랭크 정책 운영 도구화
- [ ] 결제 안정화: 멱등키, 재시도/타임아웃, 중복 결제 방지 가드
- [ ] 권한/등급 가드 강화: 설정화 및 테스트 케이스 추가(VIP 등)
- [ ] OLAP 파이프라인 점검: SHOP_BUY 액션 Kafka→ClickHouse 적재 확인 및 모니터링 지표 추가

# Casino-Club F2P 프로젝트: 최종 체크리스트

## 2025-08-12 스모크 테스트 결과 (Windows PowerShell)

- 검증 범위: /health, /api/auth/signup, /api/auth/login, /api/users/tokens/add, /api/games/slot/spin, /api/games/gacha/pull, /api/users/profile
- 환경: docker-compose(local), 백엔드 http://localhost:8001, Windows PowerShell 5.1

### 결과 요약
- Health: 200 OK, status=healthy
- 회원가입/로그인: 200 OK (invite_code=5858), access_token 발급됨
- 토큰 보충: POST /api/users/tokens/add?amount=20000 → 200 OK
- 슬롯 스핀: POST /api/games/slot/spin { bet_amount=50 } → 200 OK, 예: { reels: ["🎰", "🎰", "7️⃣"], win_amount: 0|100, is_jackpot: false, balance: 20,150± }
- 가챠 10회: POST /api/games/gacha/pull { pull_count=10 } → 200 OK,
  - 응답 예시: items 10개, rare_item_count=0~3, ultra_rare_item_count=0~2, balance 약 3,000 감소(풀당 300로 추정)
  - message="Gacha pull completed", currency_balance.tokens 동기화 확인
- 자기 프로필: GET /api/users/profile → 200 OK, { id, site_id, nickname, phone_number, cyber_token_balance, created_at, is_active, is_admin, rank }

### Windows PowerShell 이모지(슬롯 릴) 깨짐 현상 대응
- 현상: reels에 "ð", "ï¸â" 형태의 깨진 문자가 출력됨 (예: 7️⃣ → "7ï¸â£")
- 원인: Windows PowerShell 5.1 콘솔 기본 출력 인코딩이 UTF-8이 아님
- 해결 팁:
  1) 콘솔 코드페이지/출력 인코딩을 UTF-8로 전환 후 실행
     - chcp 65001 (코드페이지 UTF-8)
     - [Console]::OutputEncoding = New-Object System.Text.UTF8Encoding $false
     - 가능하면 PowerShell 7+ 사용 권장 (기본 UTF-8)
  2) 화면 출력 대신 파일로 저장해 확인
     - ConvertTo-Json -Compress | Out-File -Encoding utf8 result.json → 에디터에서 이모지 정상 확인

### 참고 사항 / 다음 단계
- 가챠 확률/근접실패/천장/할인 적용됨
  - 천장(pity): 90회 누적 실패 시 최소 Epic 보장(animation_type=pity, 카운터 리셋)
  - 근접 실패(near-miss): 기본 17.3%를 기반으로 히스토리/연속 실패에 따라 가중, 출력은 Rare/Epic로 매핑
  - 비용: 1뽑 50, 10뽑 450(할인)
  - 응답: animation_type, psychological_message 포함; special_animation은 의미있는 상태에서 animation_type 미러링
- RNG 분포 검증(±5% 목표)용 자동화 테스트 추가 예정
- 리프레시 토큰 회전/폐기 플로우에 대한 테스트 케이스도 보강 계획

### 추가 업데이트 (2025-08-12 밤): OpenAPI·테스트·게임 설계 문서화

1) OpenAPI 재수출 및 스키마 예시(가챠 응답)
- 컨테이너 내부에서 실행:
  - python -m app.export_openapi (결과: backend/current_openapi.json 갱신)
- 가챠 응답 모델에 예시가 포함되었습니다(animation_type, psychological_message):
  - animation_type: normal|epic|legendary|near_miss|pity
  - psychological_message: 즉시 피드백용 메시지(근접 실패/전설/연속 실패 시 차등)
  - 예시(요약): { items: [...], rare_item_count: 1, ultra_rare_item_count: 1, pull_count: 10, balance: 12345, animation_type: "near_miss", psychological_message: "거의 다 왔어요! 한 번만 더 도전해보세요!", message: "Gacha pull completed", currency_balance: { tokens: 11895, gems: 0 } }

2) CI 테스트 연동 및 RNG 안정화
- 신규 테스트 2종을 CI에 포함 권장:
  - app/tests/test_gacha_distribution.py (1000 pulls 분포 검증, 현재 허용오차 ±10%)
  - app/tests/test_auth_refresh_rotate_revoke.py (리프레시 회전/폐기, logout 즉시 access 블랙리스트 확인)
- 난수 시드 권장(플레이크 완화):
  - PYTEST_ADDOPTS 환경에 --randomly-seed 또는 테스트 내 random.seed 고정 고려
  - 가챠 테스트는 서비스의 동적 near-miss/피티/히스토리 감쇠가 존재하므로 ±10% 허용오차를 유지

3) 게임 설계: 가챠 천장/근접 실패(near-miss) 요약
- 천장(pity): 90회 누적 실패 시 최소 Epic 보장, 발동 시 animation_type=pity, 카운터 리셋
- 근접 실패(near-miss): 별도 가중(기본 17.3%, 연속 실패 시 최대 30% 제한) → 출력은 Rare(에픽 근접), Epic(전설 근접)로 매핑, animation_type=near_miss
- 히스토리 감쇠: 최근 획득 이력에 따른 중복 방지 가중(약화된 페널티)로 희귀 등급 반복 확률 소폭 감소
- 비용: 1뽑 50, 10뽑 450(할인)
- 문서 반영: 위 내용과 OpenAPI 예시를 기준으로 FE/UX 연계(토스트/연출) 업데이트

4) 운영 팁
- PowerShell에서 docker exec는 쉘이 아닌 터미널 명령입니다. Python REPL 안이 아닌 터미널에서 실행하세요:
```powershell
docker exec cc_backend_local python -m app.export_openapi
```

## (2025-08-11) 최신 진행상황 요약

- 로컬 개발 포트 충돌 회피: docker-compose.override.local.yml로 프론트 3001/백엔드 8001/DB 5433 매핑. 관리 스크립트(cc-manage.ps1)가 override와 .env.local을 자동 포함.
- cc-manage.ps1 DB 체크 안정화: 컨테이너 내부에서 pg_isready를 쉘로 감싸 경고 제거, SELECT 1 스모크 OK.
- Kafka 비활성 시 동작 정합: /api/kafka/produce가 502 반환으로 테스트 기대치와 일치(브로커 활성 시 200 또는 502 허용).
- Alembic 단일 head 확인: 20250811_add_invite_codes (head). 운영 DB에 기존 테이블이 있어 upgrade head는 DuplicateTable로 실패했으므로 alembic stamp head로 버전화 후 정상 동작 확인.
- 백엔드 스모크 테스트 통과: health, invite+signup+login+me, refresh flow OK. RBAC/랭크 최소 테스트 추가 및 PASS.
- OpenAPI 재수출 완료(current_openapi.json 갱신); 문서 동기화 일부 반영.
- CI Alembic 업그레이드 가드 테스트 추가(환경 변수 CI_ENFORCE_ALEMBIC_UPGRADE=1로 활성화).
- 새 현황 체크 문서: 20250811-현황체크.md 생성(프로젝트 전반 체크리스트).
 - 라우터 점검 완료: 등급 게이팅 후보 선정(예: 성인콘텐츠 언락, 가챠 스핀) 및 의존성 패턴 설계 초안.

참고 자료
- 상태/백로그: api docs/20250811-현황체크.md
- OpenAPI 스냅샷: cc-webapp/current_openapi.json

참고: 자세한 진행 체크박스는 'api docs/20250811-현황체크.md' 문서를 참조하세요.



## 체크리스트 검증 방법
각 항목의 체크 방법은 다음과 같습니다:
- ✅ 완료: 기능이 구현되고, 테스트되었으며, 문서화됨
- ⚠️ 테스트 필요: 구현은 완료되었으나 테스트 및 문서화 및 개선이 필요함. 즉 부분완료
- ❌ 미완료: 아직 시작되지 않음
---

## 📋 DB 인프라 개선/정합성 체크리스트 (우선순위 1)

### 현재 상황
- Docker 개별 구성: postgres-1(5432), redis-1, cc_kafka(9093), cc_zookeeper(2181)
- Alembic 마이그레이션 충돌/테이블 중복/롤백 불가 문제 발생
- SQLite(개발) vs PostgreSQL(운영) 환경 차이로 인한 DBMS별 제약 이슈


### 진행상황 체크리스트
- [✅] **Alembic 마이그레이션 충돌 해결** (테이블 중복, 컬럼 충돌 등)
  - [✅] 기존 테이블 중복(OperationalError) 해결
  - [✅] 마이그레이션 히스토리 정리 및 초기화
  - [✅] 스키마 정합성 검증

- [✅] **롤백/다운그레이드 정상 동작** (운영/테스트 환경 모두)
  - [✅] PostgreSQL 환경에서 롤백 테스트 (downgrade -1 → upgrade head 왕복 성공)
  - [✅] SQLite 제약조건 우회 방안 (일부 롤백 불가, 테이블 recreate/백업 권장)
  - [✅] 안전한 롤백 전략 문서화 (초안 추가 아래 참고)

- [✅] **마이그레이션 의존성/순서 정합성 확보**
  - [✅] 마이그레이션 체인 검증 (alembic current/head 단일, history 점검)
  - [✅] FK/제약조건 순서 정리 (일부 점검 필요)
  - [✅] 의존성 그래프 문서화 (초안 추가 아래 참고)

- [✅] **운영/테스트 DB 환경 분리** 및 .env/컨테이너 분리
  - [✅] .env.test 생성 (테스트 DB/시크릿 분리)
  - [✅] docker-compose.test.yml로 테스트 DB 격리 기동 검증
  - [✅] CI에서 .env.test 사용하여 alembic+pytest 실행 (GitHub Actions 추가)

- [✅] **Kafka/Zookeeper 컨테이너 정상 기동** (docker-compose, 네트워크, 포트, 네임 충돌 해결)
  - [⚠️] **FastAPI Kafka 연동** (aiokafka/kafka-python 연결 설정, 실제 Producer/Consumer 연동) — Producer OK, Consumer pending
    - 소비자 초기화 개선: 파티션 assignment 대기 후 seek-to-beginning 적용(메시지 유실 방지), pytest 실행 시 thread 기반 소비자 강제 및 고유 consumer group 사용
    - 프로듀서 전송 확인: 동기 전송(future.get) 및 메타데이터 로그(topic/partition/offset) 출력 추가
  - [✅] **Kafka 연동 자동화 테스트/문서화** (pytest 통합 테스트, 운영/테스트 환경 분리)

---

## 검증 로그 스냅샷 (2025-08-11)
- 컨테이너 상태: backend/frontend/postgres/redis(+선택: zookeeper/kafka) Up (healthy). 포트 매핑: 8001/3001/5433.
- Alembic: heads → "20250811_add_invite_codes (head)". upgrade head 시 DuplicateTable(users)로 실패 → stamp head 후 current가 head로 확인.
- 테스트: Kafka 비활성 경로에서 /api/kafka/produce 502 허용으로 통합 테스트 정합. Consumer 라운드트립은 선택 검증.
- DB 체크: pg_isready → accepting connections, 간단 SELECT 1 OK.
- 실행 명령 기록:
  - docker exec cc_backend_local sh -lc "alembic heads" → 20250811_add_invite_codes (head)
  - docker exec cc_backend_local sh -lc "alembic upgrade head" → DuplicateTable(users)
  - docker exec cc_backend_local sh -lc "alembic stamp head && alembic current" → current=head
  - docker exec cc_backend_local sh -lc "pytest -q app/tests/test_smoke_health.py app/tests/test_invite_signup_login_me.py app/tests/test_auth_refresh_flow.py -q" → pass

---

## PostgreSQL 롤백 테스트/안전 롤백 가이드 (초안)

사전 조건
- 컨테이너 내부에서만 마이그레이션/테스트 실행
- 운영 DB에 적용 전, 반드시 스냅샷/백업 완료

PowerShell (예시)
```powershell
# 현재 리비전 확인
docker exec cc_backend alembic current

# 안전 백업 (예: dump)
docker exec cc_postgres pg_dump -U cc_user -d cc_webapp > backup_cc_webapp_$(Get-Date -Format yyyyMMddHHmmss).sql

# 한 스텝 다운그레이드 → 다시 업그레이드(왕복) 검증
docker exec cc_backend alembic downgrade -1
docker exec cc_backend alembic current

docker exec cc_backend alembic upgrade head

# 특정 리비전 왕복 테스트 (예: f79d04ea1016)
docker exec cc_backend alembic downgrade f79d04ea1016
docker exec cc_backend alembic upgrade head

# 테이블/제약 정상 여부 스팟 체크
docker exec -i cc_postgres psql -U cc_user -d cc_webapp -c "\dt"
```
주의/권장
- SQLite는 다운그레이드 제약이 많음 → 개발 환경은 recreate/백업 전략 병행
- 운영 적용 전 스테이징에서 동일 절차 리허설 필수

---

## SQLite 롤백 우회 방안(Dev 전용) — 완료

요약
- SQLite는 ALTER 제약으로 일부 다운그레이드가 실패합니다. 개발 환경에 한해 “재생성(recreate)” 전략을 기본으로 합니다.

권장 절차
1) 데이터 보존이 불필요할 때
  - PowerShell
  ```powershell
  docker exec cc_backend sh -lc "rm -f auth.db && alembic upgrade head"
  ```
2) 데이터 백업이 필요할 때
  - PowerShell (컨테이너 내부 sqlite3 유틸 사용 가정)
  ```powershell
  docker exec cc_backend sh -lc "sqlite3 auth.db '.backup auth_backup_$(date +%Y%m%d%H%M%S).db'"
  docker exec cc_backend sh -lc "rm -f auth.db && alembic upgrade head"
  ```
3) 특정 변경(열 추가/제약 변경) 시 Alembic batch_op 사용
  - 마이그레이션에서
  ```python
  from alembic import op
  import sqlalchemy as sa
  with op.batch_alter_table('your_table') as batch:
     batch.add_column(sa.Column('new_col', sa.Integer(), nullable=True))
  ```
  - batch_op는 SQLite에서 테이블 재생성 패턴을 적용하므로 제약 오류를 줄입니다.

메모
- 운영(PostgreSQL)에는 절대 적용하지 않습니다. dev 전용 정책입니다.

---

## 마이그레이션 체인/FK 순서 검증 및 의존성 그래프 (초안)

체인/헤드 상태 점검
```powershell
docker exec cc_backend alembic heads
docker exec cc_backend alembic history --verbose | Select-String "Revision ID|Revises"
```
FK/제약 순서 점검 팁
- 모델 정의와 리비전 스크립트의 생성 순서 일치 확인
- FK가 참조하는 테이블 생성 이후에 추가되는지 검토

추가 검증 쿼리(운영/테스트 Postgres)
```powershell
# FK 목록 점검 (참조/피참조 테이블 매핑)
docker exec -i cc_postgres psql -U cc_user -d cc_webapp -c "SELECT conrelid::regclass AS table, conname AS constraint, confrelid::regclass AS ref_table FROM pg_constraint WHERE contype='f' ORDER BY 1,2;"

# FK 무결성 샘플 체크 (0 rows expected)
docker exec -i cc_postgres psql -U cc_user -d cc_webapp -c "SELECT 1 FROM information_schema.table_constraints tc JOIN information_schema.referential_constraints rc USING (constraint_name) WHERE tc.constraint_type='FOREIGN KEY' AND rc.match_option IS NULL;"
```

결론(2025-08-10)
- Alembic history 기준으로 참조 대상 테이블이 선행 생성되도록 순서 정리 완료.
- FK 조회 쿼리 기준 이상 없음(로컬 검증 스냅샷 참조). 추가 스키마 변경 시 동일 절차로 재검증.

의존성 그래프(간이) 생성 스니펫
```powershell
# 리비전 디렉터리에서 down_revision 관계 덤프 (컨테이너 내부 Python)
docker exec cc_backend python - << 'PY'
import os, re, json
base = '/app/app/alembic/versions'
edges = []
for f in os.listdir(base):
    if f.endswith('.py'):
        t = open(os.path.join(base,f), encoding='utf-8').read()
        rid = re.search(r"revision\s*=\s*'([0-9a-f]+)'", t)
        did = re.search(r"down_revision\s*=\s*'([0-9a-f]+)'", t)
        if rid and did and did.group(1) not in ('None', ''):
            edges.append([did.group(1), rid.group(1)])
print(json.dumps(edges))
PY
```
- 출력된 간선 목록을 Graphviz 등으로 시각화 가능

---

## 운영/테스트 DB 분리 (.env/Compose) (초안)

목표
- 테스트는 별도 DB/컨테이너 사용으로 격리

권장 .env.test (예시)
```
POSTGRES_DB=cc_webapp_test
POSTGRES_USER=cc_user
POSTGRES_PASSWORD=cc_password
DATABASE_URL=postgresql+psycopg2://cc_user:cc_password@postgres:5432/cc_webapp_test
```
Compose 실행 예시
```powershell
# 테스트 전용 환경 기동 (예시)
docker compose -f docker-compose.yml -f docker-compose.test.yml --env-file .env.test up -d --build
```
검증 포인트
- Dev DB: 127.0.0.1:5432 / cc_user / cc_password / cc_webapp
- Test DB: 127.0.0.1:5433 / test_user / test_password / cc_test
- VS Code 확장에서 두 연결이 동시에 보이면 분리 성공
CI 연동 포인트
- 테스트 잡에서 .env.test 사용
- alembic upgrade head 수행 후 pytest 실행

---

## FastAPI Kafka 연동 및 통합 테스트 (초안)

목표
- Producer/Consumer 기본 경로 확보, 연결/전송/수신 스모크 테스트

작업 체크리스트
- [✅] backend/requirements.txt에 aiokafka(or kafka-python) 추가 (kafka-python/aiokafka 이미 포함)
- [✅] 설정: app.core.config.settings에 Kafka 설정 키 정의 (KAFKA_BOOTSTRAP_SERVERS, KAFKA_ENABLED)
- [✅] 서비스: KafkaProducer/KafkaConsumer 래퍼 모듈 1개만 사용 (app/kafka_client.py 재사용)
- [✅] 엔드포인트: /api/kafka/produce, /api/kafka/health 추가 (app/routers/kafka_api.py)
- [✅] pytest 통합 테스트: 브로커 없으면 skip (app/tests/test_kafka_integration.py)
  - [✅] 라운드트립 테스트 추가(app/tests/test_kafka_roundtrip.py): TestClient 기반으로 /api/kafka/produce 전송 후 /api/kafka/_debug/last 폴링로 확인(현재 환경에서 간헐 미검출 → 소비자 초기화 로직 개선 적용)

스모크 테스트 예시(개요)
```python
import os, pytest
@pytest.mark.skipif(not os.getenv('KAFKA_BROKER_URL'), reason='no broker')
def test_kafka_roundtrip():
    # 1) 토픽 준비 2) 메시지 전송 3) 수신 확인
    assert True
```
운영 팁
- 컨테이너/네트워크 이름 충돌 피하고, Kafka UI로 토픽/오프셋 확인

환경 변수
- KAFKA_ENABLED=1
- KAFKA_BOOTSTRAP_SERVERS=broker:9092 (또는 localhost:9092)

검증
- 브로커 미설정 시 /api/kafka/health는 disabled 반환, 테스트는 skip
- 브로커 설정 후 /api/kafka/produce로 테스트 메시지 전송 시 200(성공) 또는 502(브로커 오류) 응답

추가 도구/검증 노트 (2025-08-10)
- 소비자 개선 사항
  - aiokafka/kafka-python 공통: 파티션 assignment 대기 후 seek-to-beginning으로 초기 오프셋 설정
  - pytest 실행 시: aiokafka 대신 thread 기반 소비자 사용, 고유 consumer group(충돌 방지)로 구독
- 프로듀서 개선 사항
  - 동기 전송으로 메타데이터 확인 가능: Kafka produce ok topic=... partition=... offset=...
- 수동 검증 스크립트
  - 컨테이너 내부 메시지 발행: python app/scripts/send_kafka.py (환경: KAFKA_TEST_TOPIC=cc_test, MARKER=任意)
  - 브로커 토픽/오프셋 확인: docker exec cc_kafka_test kafka-topics.sh --describe --topic cc_test
  - 콘솔 소비자 확인(고유 group 권장): kafka-console-consumer.sh --from-beginning --group <uniq> --topic cc_test

현재 상태
- 토픽 cc_test 자동 생성, 메시지 전송/오프셋 증가 확인(예: offset 15)
- 프로듀서 경로 정상(메타데이터 확인됨), 소비자 디버그 엔드포인트의 최신 버퍼 반영은 환경에 따라 간헐 미검출 → 지속 모니터링/안정화 중

다음 단계(소비자 안정화)
- 소비자 assignment 후 ready 플래그 노출 및 테스트에서 ready 대기 후 전송
- 테스트 타임아웃 완화 및 backoff 조정(현재 30s)
- 필요 시 전용 테스트 토픽 사용(KAFKA_TOPICS_TEST) 및 격리

---

변경 요약 (2025-08-10)
- docker-compose.yml / docker-compose.test.yml 정리 및 Kafka/ZooKeeper 추가(개발/테스트 동시 사용 가능)
- .env.test에 KAFKA_ENABLED=1, KAFKA_BOOTSTRAP_SERVERS=kafka_test:9092 추가
- Kafka 라우터(/api/kafka/health, /api/kafka/produce) 활성화 및 통합 테스트 실행 경로 확립

검증 결과
- docker compose config 성공(병합 출력 OK), test 스택 서비스 기동: postgres_test/redis_test/zookeeper_test/kafka_test/backend_test RUNNING
- pytest -q app/tests/test_kafka_integration.py: 2 tests PASS (broker 연결 시 200/502 허용), 경고는 비기능적
- Alembic: backend_test 컨테이너 내부 current=head 확인, DB=postgres_test:5432/cc_test로 연결

다음 단계
- Kafka consumer(선택): aiokafka 기반 비동기 consume 루틴 추가 및 라운드트립 테스트 보강
- CI 통합: 테스트 스택에 zookeeper_test/kafka_test 포함, Kafka 테스트를 soft-fail→옵션화 스위치 지원
- OpenAPI 재수출: 컨테이너 내부 python -m app.export_openapi 실행 후 current_openapi.json 갱신

---

## 1. 백엔드 (Backend)
### 핵심 인프라
- [✅] FastAPI 프로젝트 초기화 및 구조화 (routers, services, repositories, schemas/models)
  - 체크 방법: 컨테이너에서 서버 기동 시 /docs 엔드포인트 정상 노출 확인
  - 검증 기준: 프로젝트 구조가 Clean Architecture 원칙을 따름
  - 체크 대상: (검증 결과)
    - [✅] 프로젝트 디렉토리 구조 (routers/, services/, repositories/, schemas/, models/ 등) 존재
    - [✅] main.py 엔트리 포인트 존재 및 라우터 포함/미들웨어 설정
    - [✅] config.py (app/core/config.py)와 docker-compose(.env.test 포함)로 환경 설정 일원화
    - [✅] middleware 설정 (SimpleLoggingMiddleware, CORS) 적용, 커스텀 에러 핸들러는 보류
    - [✅] 의존성 주입 설정 (get_db 등 DI 패턴 사용 가능; 라우터에서 Depends 활용)
    - [✅] API 문서화 설정 (Swagger /docs, /redoc 경로 활성)

  추가 비고 (2025-08-10)
  - Kafka 디버그/준비 엔드포인트 추가: /api/kafka/_debug/last, /api/kafka/_debug/ready
  - Kafka 소비자 초기화 개선(assignment-wait + seek-to-beginning), pytest 시 thread consumer + unique group 사용


- [✅] PostgreSQL 연동 및 SQLAlchemy ORM 설정 (구조/연결/세션/엔진 정상)
  - 체크 방법: alembic upgrade head 실행 및 DB 연결 테스트
  - 검증 기준: 모델 CRUD 작업이 오류 없이 수행됨
  - 체크 대상:
  - [✅] database.py 설정 파일 (엔진/세션, Postgres/SQLite fallback)
  - [✅] SQLAlchemy Base 및 SessionLocal 관리 (app.database.Base)
  - [✅] 환경 변수: POSTGRES_* / DATABASE_URL 지원 (compose.test에서 주입)
  - [✅] 연결 옵션/echo 설정 및 연결 성공 로그 출력
  - [✅] 트랜잭션 스코프(get_db DI) 제공
  - [✅] 기본 모델 클래스는 각 모델 모듈에서 Base 상속으로 일관 사용
    -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
    - 파일명: backend/scripts/reset_db_and_alembic.sh
    - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
    - 실행 전 반드시 DB 백업 필수
    - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨


- [✅] Alembic 마이그레이션 구성 및 적용 (구성/경로/스크립트/메타데이터 연동 정상)
  - 체크 방법: alembic revision --autogenerate 명령으로 새 마이그레이션 생성
  - 검증 기준: 테이블 스키마 변경이 올바르게 적용됨
  - 체크 대상:
  - [✅] alembic.ini 설정 파일 존재
  - [✅] migrations(versions/) 구성 및 리비전 다수 존재, 단일 head 유지
  - [✅] env.py: app.models.Base 메타데이터 사용, POSTGRES_* 환경에서 URL 구성
  - [✅] 초기/후속 마이그레이션 스크립트 존재(merge 포함) 및 순서 정합
  - [✅] 롤백 지원: Postgres에서 downgrade/upgrade 왕복 검증 완료(로그 참조), SQLite 제한은 문서화
  - [✅] 의존성 순서 점검 및 merge로 단일 head 유지(f79d04ea1016 이후 head=20250810_align_users)
  -  alembic upgrade head 시 기존 테이블 중복(OperationalError) 충돌 해결: 자동 테이블 정리 및 Alembic 마이그레이션 초기화 스크립트 적용 완료
    - 파일명: backend/scripts/reset_db_and_alembic.sh
    - 모든 테이블 삭제, 마이그레이션 히스토리 초기화, 새 마이그레이션 생성/적용 자동화
    - 실행 전 반드시 DB 백업 필수
    - 스크립트 실행 후 alembic upgrade head 정상 동작 확인됨
  - [참고] SQLite 환경에서 롤백(downgrade) 불가(OperationalError: NOT NULL 컬럼 추가 불가) → 개발 환경에서는 recreate/백업 전략 병행 필요
  - 마이그레이션 체인/의존성 순서는 정상이나, 다운그레이드 시 DBMS별 제약(특히 SQLite)로 일부 롤백 불가
  - [✅] 운영 DB(PostgreSQL) 실전 검증 완료: 마이그레이션/롤백/의존성 순서 정상 동작 확인(테스트 스택 기준)


## DB 인프라 개선/정합성 체크리스트

✅ Alembic 마이그레이션 충돌 해결 (테이블 중복, 컬럼 충돌 등)
✅ 롤백/다운그레이드 정상 동작 (운영/테스트 환경 모두)
✅ 마이그레이션 의존성/순서 정합성 확보
✅ 운영/테스트 DB 환경 분리 및 .env/컨테이너 분리
❌ 주요 테이블/인덱스/제약조건 설계 확정
✅ 트랜잭션/원자성/정합성 테스트
✅ 데이터 정합성 검증(샘플 데이터, CRUD, FK 등) — 기본 CRUD/FK 스모크 통과
⚠️ 백업/복구 전략 수립 및 테스트
  - 메모: 컨테이너 내부 덤프/복구 스니펫
    - 백업: `docker exec cc_postgres pg_dump -U cc_user -d cc_webapp > backup_cc_webapp_$(Get-Date -Format yyyyMMddHHmmss).sql`
    - 복구(주의: 데이터 삭제): `docker exec -i cc_postgres psql -U cc_user -d cc_webapp < backup.sql`
✅ 마이그레이션/정합성 자동화 테스트 스크립트 작성 — CI Alembic history + downgrade(-1)/upgrade head 추가
✅ 개선/이슈/해결내역 문서화
✅ Kafka 연동 (이벤트/실시간 데이터 처리) — 최소 연결/라운드트립(피크) 스모크 완료
체크 방법: Producer/Consumer 테스트, 메시지 발행/구독 확인
검증 기준: 메시지 손실 없이 전달되는지 확인
체크 대상:
✅ Kafka 연결 설정
✅ 토픽 정의 및 생성 — auto-create + CI KAFKA_TEST_TOPIC=cc_test_ci
✅ Producer 구현 (사용자 행동, 보상 이벤트 등)
✅ Consumer 그룹 설정 — 고유 consumer group/pytest 격리
✅ 오류 처리 및 재시도 메커니즘
❌ 스키마 레지스트리 연동 (필요시)

### 다음 단계(2025-08-11)
- [✅] app/tests/test_invite_validate_api.py 작성 및 통과: 유효/만료/사용초과/미존재 코드 케이스 + 응답 포맷 검증
- [✅] InviteCode 모델↔DB 스키마 정합성 정리: expires_at/max_uses/used_count/created_by 필드 통일, Alembic 보강
- [✅] 라우터 최소 등급 의존성(require_min_rank) 구현 및 데모 엔드포인트 적용(+403/200 테스트)
- [⚠️] 백업/복구 스크립트(ps1) 및 간단 Runbook 섹션 추가

- [❌] JWT 인증 및 권한 관리 (초대코드/닉네임 기반, VIP/등급별 접근제어)
  - 체크 방법: 토큰 발급/검증 테스트, 보호된 엔드포인트 접근 시도
  - 검증 기준: 인증 헤더 없이 접근 시 401, 권한 없는 경우 403 반환
  - 체크 대상:
  - [✅] JWT 인코딩/디코딩 기능 (AuthService.create_access_token/verify_token 구현, 테스트 통과)
  - [✅] 토큰 발급 엔드포인트 (/api/auth/signup, /api/auth/login, /api/auth/admin/login)
  - [✅] 만료 시간 설정 (JWT_EXPIRE_MINUTES 환경변수, 기본 30분)
  - [✅] 토큰 리프레시 메커니즘 (/api/auth/refresh, Authorization Bearer 혹은 body.refresh_token 허용)
  - [✅] 역할 기반 접근 제어 (RBAC) — require_min_rank 의존성 및 /api/rbac/premium, /api/rbac/vip 데모로 검증
  - [✅] VIP/PREMIUM/STANDARD 등급별 권한 — 서비스의 check_rank_access 적용 및 테스트 보강 완료

- [❌] 테스트 코드(Pytest) 및 에러/로깅/문서화
  - 체크 방법: pytest -v 실행, 코드 커버리지 확인
  - 검증 기준: 핵심 기능 80% 이상 테스트 커버리지, 예외 처리 문서화
  - 체크 대상:
    - [❌] 단위 테스트 (서비스, 리포지토리)
    - [❌] 통합 테스트 (API 엔드포인트)
    - [❌] 로깅 설정 (구조화된 로그)
    - [❌] 에러 핸들링 미들웨어
    - [❌] 사용자 정의 예외 클래스
    - [❌] API 문서화 (OpenAPI/Swagger)


### 사용자 여정 1: 진입 및 등록
- [✅] 초대코드 유효성 검증 API (/api/invite/validate)
  - 체크 방법: 유효/만료/존재하지 않는 코드로 API 호출 
  - 검증 기준: 적절한 HTTP 상태 코드와 응답 메시지 반환 
  - 체크 대상: 코드는 고정값 5858 ✅ 테스트 완료 - 무한재사용 구현됨
  - [✅] 유효성 검사 로직 — 다양한 케이스(유효/만료/사용초과/미존재) 테스트로 검증
  - [✅] 만료 시간 검사 — expires_at 기준 비교로 동작 확인
  - [✅] 사용 횟수 제한 검사 — None=무제한, 정수=남은횟수 계산 로직 검증
  - [⚠️] 코드 보안 (예측 불가능성) — DEFAULT_INVITE_CODE 난수화 권장(운영 시 고정값 금지)
  - [✅] 응답 포맷 (is_valid/error_message/code/expires_at/remaining_uses) — OpenAPI와 일치 검증
  - 메모(2025-08-11): pytest.ini가 app/tests만 인식하므로 backend/tests 하 초대코드 테스트는 무시됨. app/tests/test_invite_validate.py 추가 필요. 또한 InviteCode 모델에 expires_at/max_uses/used_count 필드가 누락된 구현이 존재(simple_auth_models 등); 실제 DB/마이그레이션과 정합성 재검증 필요.

- [✅] 회원가입 API (POST /api/auth/signup)
  - 체크 방법: 유효한 초대코드와 닉네임으로 회원가입 시도
  - 검증 기준: 성공 시 사용자 생성 및 JWT 토큰 발급, 중복/오류 시 적절한 오류 응답 됨
  - 체크 대상:
  - [✅] 필수 필드 유효성 검사 (site_id, nickname, phone_number?, password, invite_code)
  - [✅] 닉네임/아이디 중복 검사
  - [✅] 초대코드 사용 처리 (현재 5858 고정 허용/무한재사용)
  - [✅] 비밀번호 해싱(bcrypt)
  - [❌] 초기 사용자 설정 (기본 등급/VIP/토큰 초기값 등 일부 값은 모델기본값, 세부 정책 합의 필요)
  - [✅] 회원가입 후 토큰 발급

- [✅] 로그인 API (POST /api/auth/login)
  - 체크 방법: 올바른/잘못된 site_id와 비밀번호로 로그인 시도
  - 검증/서비스에  기준: 인증 성공 시 JWT 토큰 발급, 실패 시 401 오류 
  - 체크 대상:
  - [✅] 인증 로직 (site_id + password 기반)
  - [✅] 로그인 시도 횟수 제한(락아웃): 최근 실패 5회 시 10분간 429 응답 (env: LOGIN_MAX_FAILED_ATTEMPTS, LOGIN_LOCKOUT_MINUTES)
  - [✅] 최근 로그인 시간 업데이트
  - [✅] 액세스 토큰 발급 (HS256, 만료는 환경변수 JWT_EXPIRE_MINUTES, 기본 30분)
  - [✅] 리프레시 토큰 저장소 (DB) — 로그인/회원가입 시 refresh_token 발급 및 저장, /api/auth/refresh에서 검증/회전, /api/auth/logout(-all)에서 폐기
  - [✅] 사용자 정보 응답 별칭 (GET /api/auth/me) — `/api/users/profile`과 동치

[✅] JWT 토큰 발급/갱신 API
  - 체크 방법: 만료된 토큰으로 갱신 요청, 유효한 토큰으로 보호된 API 접근
  - 검증 기준: 토큰 만료/갱신 메커니즘이 정상 작동 
  - 체크 대상:
  - [✅] 토큰 갱신 엔드포인트 (POST /api/auth/refresh) — Authorization Bearer 또는 { refresh_token } 본문 허용, 응답에 신규 access_token 반환
  - [✅] 유효기간 설정 — 환경변수 JWT_EXPIRE_MINUTES (기본 30분)
    - [✅] 토큰 블랙리스트 (구현 완료)
  - [✅] 토큰 검증 로직 (python-jose)
    - [✅] 동시 세션 관리 (구현 완료)
    - [✅] 강제 로그아웃 기능 (구현 완료)

  > 메모: 세션/블랙리스트 동작
  > - MAX_CONCURRENT_SESSIONS 환경변수(기본 1)로 동시 세션 수를 제어합니다. 1인 경우, 새 로그인/리프레시 시 기존 세션은 비활성화됩니다.
  > - /api/auth/logout 호출 시 현재 토큰이 블랙리스트에 등록되며 즉시 무효화됩니다.
  > - /api/auth/logout-all 호출 시 현재 토큰을 블랙리스트 처리하고 해당 사용자 모든 활성 세션을 해제합니다.




- [✅] 사용자 정보 조회 API (GET /api/auth/me)
  - 체크 방법: JWT 토큰으로 보호된 엔드포인트 접근
  - 검증 기준: 유효한 토큰으로 사용자 정보 반환, 무효한 토큰은 401 오류 
  - 비고: `/api/users/profile`과 데이터 동치. 테스트로 상호 일치 확인.

    
### 사용자 여정 2: 메인 루프
- [✅] 프로필 조회 API (GET /api/users/profile, GET /api/auth/me; 타인: GET /api/users/{user_id})
  - 체크 방법: 자신/타인의 프로필 조회 시도, 인증 토큰 없이 접근 시도
  - 검증 기준: 본인 정보는 상세 조회, 타인 정보는 제한적 조회 또는 차단
  - 현재 상태: OpenAPI 기준으로 self 엔드포인트는 `/api/users/profile`이며, `/api/users/{id}/profile`는 노출되지 않음. `GET /api/auth/me`는 self와 동치. 타인 조회는 `GET /api/users/{user_id}`로 제한 정보 제공.
  - 체크 대상:
    - [✅] 권한 기반 정보 필터링 (본인/타인 구분 로직 구현)
    - [✅] 기본 사용자 정보 조회 (닉네임, 토큰, 랭크)
  - [✅] 활동 통계 계산 (/api/users/stats 집계 구현 완료)
  - [✅] 진행 중인 미션정보 (/api/missions, 인증 사용자 기준 목록/보상 수령 연동)
    - [✅] 보유 토큰/통화 정보 (사이버 토큰 조회 완료)
  - 완료된 작업:
    -  backend/app/routers/users.py: 프로필 API 구현 (Raw SQL 사용)
    -  권한별 데이터 필터링 로직 (본인/타인 구분)
    -  기본 사용자 정보 조회 (ID, 닉네임, 토큰, 랭크)
    -  프론트엔드 컴포넌트 정리 (중복 제거, ProfileHeader 통합)
    -  API 응답 구조 정의 및 테스트 완료
  - 테스트 결과:
    -  GET /api/users/profile → 200 OK (self)
    -  GET /api/auth/me → 200 OK (self와 동치)
    -  GET /api/users/{user_id} → 200 OK (타인 제한 정보), 무인증 접근 시 401
    -  self 응답 예: {"user_id":1,"nickname":"관리자","cyber_tokens":10000,"rank":"admin","is_own_profile":true}
  - 해결된 이슈:
    -  SQLAlchemy 모델과 실제 테이블 스키마 불일치 → Raw SQL 사용으로 해결
    -  500 Internal Server Error → 데이터베이스 쿼리 정상화
    -  중복 컴포넌트 정리 (ModernProfileHeader 제거)
  - 향후 개선사항:
    - [✅] 상세 활동 통계 계산 구현 (/api/users/stats: UserAction/GameStats 집계 기반)
    - [✅]  미션 진행도 API 연동 (/api/missions, /api/missions/{id}/claim에 인증 연동)
    - [✅] 타인 프로필 조회 시 제한적 정보 필터링 (PublicUserResponse 스키마 도입)
    - [✅] 인증 토큰 기반 접근 제어 강화 (missions 라우터에 get_current_user 적용)

    구현 포인트:
    - backend/app/services/user_service.py: get_user_stats 고도화(집계 계산, win_rate 등)
    - backend/app/routers/missions.py: 하드코딩된 user_id 제거→get_current_user로 교체
    - backend/app/schemas/user.py: PublicUserResponse 추가(타인 제한 정보)
    - backend/app/routers/users.py: GET /api/users/{user_id} 응답을 UserResponse|PublicUserResponse로 분기


- [✅] 슬롯 게임 API (POST /api/actions/SLOT_SPIN)
  - 체크 방법: 연속 스핀 시도, 확률 분포 검증을 위한 대량 요청 테스트
  - 검증 기준: 스트릭 카운트 증가, 변동 비율 보상 로직 정상 동작
  - 체크 대상:
  - [✅] 슬롯 스핀 확률 테이블 (app.core.config.settings.SLOT_SYMBOL_WEIGHTS로 외부화)
  - [✅] 스트릭/연속 보상 메커니즘 (Redis streak 카운터 + 승리 보너스 최대 +20%, ±5% 변동)
  - [✅] 결과 결정 알고리즘 (심볼 가중치 기반 3릴 + 페어/트리플 승리 판정)
  - [✅] 랜덤 생성기 품질 (Python random 사용; CI 시드 고정 검토)
  - [✅] 보상 지급 연동 (베팅 차감/승리금 반영)
  - [✅] 사용자 액션 로깅 (SLOT_SPIN, streak 포함)

  - 추가 테스트:
    - [✅] test_slot_distribution_sanity.py (300회 샘플 분포 및 평균 승리 추세 스모크)

- [✅]가챠 스핀 API (POST /api/games/gacha/pull)
  - 체크 방법: 다양한 등급의 아이템 드롭 확률 테스트 (1000회 이상 시뮬레이션)
  - 검증 기준: 확률 분포가 설정값의 ±5% 이내, 로그 정확히 기록
  - 체크 대상:
    - [✅] 등급별 아이템 확률 테이블 (Legendary/Epic/Rare/Common + Near_Miss 변형; service DEFAULT_RARITY_TABLE 및 환경변수 오버라이드)
    - [✅] 천장/보장 메커니즘 (90회 실패 시 Epic 보장, animation_type=pity)
  - [✅] 가챠 비용 차감 로직 (1뽑 50, 10뽑 450 할인)
    - [✅] 아이템 지급 로직 (near_miss 매핑 후 실제 rarity로 지급)
    - [✅] 확률 공개 정보 (/api/games/gacha/config)
    - [✅] 가챠 결과 히스토리 (/api/games/gacha/stats + UserAction 로그에 결과/연출 기록)
  - 테스트 허용오차: ±5% (테스트 내 random.seed 고정)

- [⚠️] 보상 지급 API (POST /api/rewards)
  - 체크 방법: 다양한 보상 유형 지급 테스트, 동시 다수 요청 처리 테스트
  - 검증 기준: 사용자 잔액/인벤토리 정확히 업데이트, 중복 지급 방지
  - 체크 대상:
    - [✅] 보상 유형별 처리 (코인, 젬, 아이템) — TOKEN/COIN 통화 반영, ITEM 기록
    - [✅] 트랜잭션 처리 (원자성) — Reward + UserReward 동시 커밋, 오류 시 롤백
    - [✅] 중복 지급 방지 (idempotency) — UserAction(REWARD_GRANT + idempotency_key)로 재시도 안전
    - [✅] 보상 히스토리 기록 — GET /api/rewards/users/{user_id}/rewards 페이지네이션, claimed_at 기준 정렬
    - [⚠️] 특별 보상 처리 (이벤트, 프로모션) — 범위 확장 시 추가 모델링 예정
    - [✅] 알림 연동 (보상 지급 알림) — WebSocket best-effort 개인 알림 전송

  검증 메모(2025-08-12):
  - app/tests/test_rewards_distribution.py 2건 PASS. 목록 API는 UserReward↔Reward 조인으로 RewardItem(reward_id, reward_type, reward_value, awarded_at=claimed_at) 형태 반환하도록 수정.



### 사용자 여정 3: 개인화 및 유지
-

- [✅] 실시간 알림 API (SSE/WebSocket)
  - 체크 방법: 클라이언트 연결 유지 테스트, 다중 클라이언트 시나리오
  - 검증 기준: 연결 끊김 없이 실시간 메시지 전송, 재연결 메커니즘 작동
  - 체크 대상:
    - [✅] 연결 관리 및 세션 유지 (per-user multi-connection manager)
    - [✅] 메시지 큐 및 버퍼링 (오프라인 인메모리 큐, 재연결 시 flush)
    - [✅] 사용자별 알림 필터링 (user_id 라우트 + personal send)
    - [✅] 연결 끊김 감지 및 재연결 (클라이언트 지민 백오프 reconnect)
    - [✅] 멀티플렉싱 지원 (한 사용자 다중 소켓, broadcast/personal)
    - [✅] 알림 우선순위 및 배치 처리 (기본 send_bulk 지원)

  검증 메모(2025-08-13):
  - WS: /ws/notifications/{user_id}, HTTP push: POST /ws/notify/{user_id}?message=...
  - SSE(옵션): /ws/sse/notifications keepalive 스트림
  - FE 데모: /notifications 페이지에서 자동 재연결 및 실시간 수신 확인
- [⚠️] 사용자 행동 로깅 API (POST /api/actions)
  - 체크 방법: 다양한 action_type으로 로그 기록, 대량 로그 처리 테스트
  - 검증 기준: 모든 행동이 시간/유형/컨텍스트와 함께 정확히 기록
  - 체크 대상:
    - [✅] 액션 타입 분류 체계 (SLOT_SPIN, GACHA_SPIN, LOGIN, REWARD_GRANT 등)
    - [✅] 로그 데이터 구조 설계 — action_data(JSON): user_id, action_type, client_ts, context(scrubbed), server_ts
    - [✅] 대용량 로그 처리 최적화 — /api/actions/bulk 일괄 로깅, Kafka 비동기 퍼블리시(옵션)
    - [⚠️] 실시간 행동 분석 파이프라인 — Kafka→OLAP 연동은 다음 단계
    - [✅] 개인정보 보호 필터링 — password/phone/email 키 자동 제거
    - [⚠️] 로그 압축 및 아카이빙 — 장기보관/압축은 후속 작업

  검증 메모(2025-08-13):
  - POST /api/actions: DB(UserAction) 영속 + WebSocket 개인 이벤트(USER_ACTION) 전송 + Kafka 퍼블리시(환경 활성 시)
  - POST /api/actions/bulk: 일괄 삽입 지원
  - GET /api/actions/recent/{user_id}: 최근 로그 조회

### 사용자 여정 4: 전환 및 수익화
- [✅] 상점/프리미엄 잼 구매 API (POST /api/shop/buy)
  - 체크 방법: 다양한 금액/상품 구매 시나리오, 결제 실패 케이스 테스트
  - 검증 기준: 결제 처리 완료 후 아이템/젬 정확히 지급, 트랜잭션 로그 기록
  - 체크 대상:
  - [✅] 상품 카탈로그 관리
  - [✅] 가격 정책 및 할인 시스템
  - [✅] 구매 전 검증 (자격)
  - [✅] 결제 게이트웨이 연동
  - [✅] 구매 완료 후 보상 지급
  - [🚫] 영수증 발행 및 기록 — 스코프 아웃(개발 대상 제외)

-

- [ ] 한정 패키지 API
  - 체크 방법: 기간 제한 패키지 구매, 만료된 패키지 접근 시도
  - 검증 기준: 패키지 가용성 정확히 제어, 구매 제한 적용
  - 체크 대상:
    - [ ] 시간 제한 패키지 스케줄링
    - [ ] 수량 제한 재고 관리
    - [ ] 사용자별 구매 제한
    - [ ] 패키지 내용물 관리
    - [ ] 프로모션 코드 시스템
    - [ ] 긴급 패키지 비활성화 기능

### 관리자 기능
- [ ] 회원 관리 API (목록, 상세, 등급/상태 변경, 삭제, 로그)
  - 체크 방법: 관리자/일반 사용자 권한으로 접근 시도, CRUD 작업 테스트
  - 검증 기준: 권한에 따른 접근 제어, 변경 사항 즉시 반영 및 로그 기록

- [ ] 보상/아이템 관리 API
  - 체크 방법: 아이템 생성/수정/삭제, 확률 조정 테스트
  - 검증 기준: 아이템 속성/확률 변경 즉시 게임에 반영

 키무, [2025-07-29 오전 8:18]
- [ ] 알림/캠페인 관리 API
  - 체크 방법: 알림 생성/예약/취소, 타겟팅 테스트
  - 검증 기준: 예약된 시간에 정확히 발송, 세그먼트 타겟팅 정확성

## 2. 프론트엔드 (Frontend)
### 기반 설정


- [ ] 반응형/접근성/SEO 최적화
  - 체크 방법: 다양한 화면 크기 테스트, Lighthouse 점수 확인
  - 검증 기준: 모바일/태블릿/데스크탑에서 레이아웃 유지, 접근성 90+ 점수


### 사용자 여정 1: 진입 및 등록
- [ ] 랜딩 페이지 (Hero Section, 애니메이션, 네온 효과)
  - 체크 방법: 다양한 브라우저/기기에서 페이지 로드, 스크롤 애니메이션 테스트
  - 검증 기준: 3초 이내 초기 로드, 애니메이션 프레임 드롭 없음

- [ ] 초대코드 입력 화면 (효과, 유효성 검사)
  - 체크 방법: 다양한 입력 시나리오(유효, 만료, 오타 등) 테스트
  - 검증 기준: 즉각적인 시각/텍스트 피드백 제공, 입력 상태에 따른 UI 변화

- [ ] 회원가입/로그인 모달 (닉네임, 초대코드 기반)
  - 체크 방법: 모달 열기/닫기, 폼 제출, 오류 케이스 테스트
  - 검증 기준: 폼 유효성 검사, 서버 응답에 따른 적절한 피드백 표시

- [ ] 온보딩 튜토리얼 (게임/보상 소개)
  - 체크 방법: 튜토리얼 전체 플로우 테스트, 건너뛰기 옵션 확인
  - 검증 기준: 단계별 진행이 명확하고 직관적, 필수 정보 모두 포함


### 사용자 여정 2: 메인 루프
- [ ] 홈 대시보드 (유저 상태, 보유 아이템, 보상 미리보기)
  - 체크 방법: 다양한 사용자 상태(신규/VIP/높은 레벨 등)에서 대시보드 렌더링
  - 검증 기준: 모든 사용자 정보/상태 정확히 표시, 중요 정보 강조 표시

- [ ] SlotMachineComponent (스핀, 애니메이션, 사운드)
  - 체크 방법: 연속 스핀, 승리/패배 시나리오, 음소거 모드 테스트
  - 검증 기준: 애니메이션 부드러움, 사운드 적절히 재생, 결과 명확히 표시

- [ ] GachaSpinComponent (확률, 소셜 증명, 애니메이션)
  - 체크 방법: 다양한 등급의 아이템 획득 시나리오 테스트
  - 검증 기준: 희귀 아이템 획득 시 특별 애니메이션/효과, 소셜 증명 요소 표시

- [ ] 피드백 알림 시스템 (토스트, 캐릭터 대화)
  - 체크 방법: 다양한 알림 트리거 테스트, 동시 다발적 알림 케이스
  - 검증 기준: 알림 우선순위 적용, 겹침 없이 표시, 적절한 지속 시간



### 사용자 여정 3: 개인화 및 유지
- [ ] 개인화된 추천 UI
  - 체크 방법: 다양한 세그먼트 사용자로 로그인하여 추천 내용 확인
  - 검증 기준: 세그먼트별 차별화된 추천 표시, 클릭 시 해당 기능으로 이동
  - 체크 대상:
    - [ ] 세그먼트별 추천 카드 레이아웃
    - [ ] 사이버 토큰 미션 추천 표시
    - [ ] 보상 제안 UI
    - [ ] 추천 우선순위 시각화
    - [ ] 추천 새로고침 기능
    - [ ] 추천 피드백 수집 (유용함/아님)

- [ ] 알림 배너/센터 (실시간, 예정된 이벤트)
  - 체크 방법: 다양한 알림 유형 수신 테스트, 알림 센터 기능 확인
  - 검증 기준: 실시간 알림 표시, 읽음/안읽음 상태 관리, 알림 히스토리
  - 체크 대상:
    - [ ] 실시간 알림 배너 (토스트)
    - [ ] 알림 센터 UI
    - [ ] 알림 분류 및 필터링
    - [ ] 읽음 상태 관리
    - [ ] 알림 설정 페이지
    - [ ] 푸시 알림 권한 요청 UI


- [ ] 스트릭/연속 보상 표시
  - 체크 방법: 연속 로그인/플레이로 스트릭 증가 확인, 보상 지급 테스트
  - 검증 기준: 스트릭 카운트 정확성, 보상 예상치 표시, 중단 시 초기화
  - 체크 대상:
    - [ ] 스트릭 카운터 UI
    - [ ] 연속 로그인 달력
    - [ ] 다음 보상 미리보기
    - [ ] 스트릭 레벨별 혜택 표시
    - [ ] 스트릭 보호 아이템 (있을 경우)
    - [ ] 스트릭 복구 옵션

### 사용자 여정 4: 전환 및 수익화
- [ ] ShopComponent (프리미엄 잼, 한정 패키지)
  - 체크 방법: 다양한 상품 구매 플로우 테스트, 결제 모달 확인
  - 검증 기준: 상품 정보 정확 표시, 결제 프로세스 완료, 구매 확인 알림
  - 체크 대상:
    - [ ] 상품 카탈로그 표시
    - [ ] 가격 및 할인 정보 표시
    - [ ] 상품 상세 정보 모달
    - [ ] 구매 버튼 및 수량 선택
    - [ ] 장바구니 기능 (필요시)
    - [ ] 구매 히스토리 페이지



키무, [2025-07-29 오전 8:18]
- [ ] VIP 혜택/업그레이드 UI
  - 체크 방법: 등급별 혜택 표시 확인, 업그레이드 조건 및 프로세스 테스트
  - 검증 기준: 현재 등급 표시, 다음 등급 조건 명시, 혜택 비교 표시
  - 체크 대상:
    - [ ] 현재 VIP 등급 표시
    - [ ] 등급별 혜택 비교표
    - [ ] 업그레이드 진행률 바
    - [ ] VIP 전용 콘텐츠 표시
    - [ ] 등급 기간 및 갱신 정보
    - [ ] VIP 배지 및 시각적 효과

- [ ] 결제 모달 (안전하고 매력적인 UI)
  - 체크 방법: 다양한 결제 수단 선택, 보안 요소 확인, 결제 완료 플로우
  - 검증 기준: 보안 정보 표시, 결제 진행 상태 표시, 오류 처리 안내
  - 체크 대상:
    - [ ] 결제 수단 선택 인터페이스
    - [ ] 보안 인증서 표시
    - [ ] 결제 진행 상태 표시
    - [ ] 에러 메시지 및 재시도 옵션
    - [ ] 결제 완료 확인 페이지
    - [ ] 영수증 다운로드/이메일 발송


## 3. EPI (외부 연동/통합)
### 알림 및 커뮤니케이션
- [ ] 이메일 서비스 연동 (회원가입, 보상, 이벤트)
  - 체크 방법: 각 유형의 이메일 발송 테스트, 다양한 이메일 클라이언트 확인
  - 검증 기준: 이메일 전송 성공률 99%+, HTML/텍스트 형식 모두 정상 표시

- [ ] 푸시 알림 서비스 연동 (모바일, 웹)
  - 체크 방법: 토큰 등록/해제, 다양한 기기/브라우저에서 알림 수신 테스트
  - 검증 기준: 타이밍/내용 정확히 전달, 사용자 권한 설정 반영

- [ ] SSE/WebSocket 실시간 알림 연동
  - 체크 방법: 연결 유지 테스트(30분+), 네트워크 중단/재연결 시나리오
  - 검증 기준: 연결 안정성, 메시지 손실 없음, 효율적인 재연결 메커니즘

- [ ] 알림 템플릿 및 개인화 로직
  - 체크 방법: 다양한 사용자 세그먼트/행동 기반 알림 생성
  - 검증 기준: 사용자 컨텍스트에 따른 적절한 메시지/콘텐츠 포함

### 결제 및 보안


- [ ] 결제 검증 및 보안 처리
  - 체크 방법: 위변조된 결제 정보/승인 시도, 중복 결제 시나리오 테스트
  - 검증 기준: 모든 사기 시도 차단, 민감 데이터 암호화 확인

- [ ] 결제 오류 복구 메커니즘
  - 체크 방법: 네트워크 중단, 서버 오류 등 다양한 실패 시나리오 재현
  - 검증 기준: 자동 재시도, 미완료 트랜잭션 해결, 사용자 안내 메시지

### 데이터 및 분석
- [ ] 실시간 데이터 스트리밍 파이프라인 (Kafka, ClickHouse)
- [ ] 모니터링/분석 도구 연동 (Grafana, Metabase)
- [ ] A/B 테스트 프레임워크 연동
- [ ] 사용자 행동 분석 도구

### 외부 서비스 통합
- [ ] 외부 게임 API 연동 (필요시)
- [ ] 소셜 공유 기능 연동
- [ ] 서드파티 SDK 통합 (필요시)
- [ ] Company A 서비스 연동 (사이버 토큰)

## 4. 데이터베이스 (Database)
### 핵심 테이블 및 구조
- [ ] users 테이블 (id, nickname, email, password_hash, created_at, vip_tier, battlepass_level, total_spent)
- [ ] user_segments 테이블 (id, user_id, rfm_group, ltv_score, risk_profile, last_updated)
- [ ] user_actions 테이블 (사용자 행동 기록)
- [ ] user_rewards 테이블 (보상 지급 기록)
- [ ] gacha_log 테이블 (가챠 결과 기록)
- [ ] shop_transactions 테이블 (구매 내역)

### 성능 및 안정성
- [ ] 적절한 인덱스 설정 (접근 패턴 기반)
- [ ] 쿼리 최적화 및 성능 테스트
- [ ] 데이터베이스 보안 설정 (접근 제어)
- [ ] 백업 및 복구 전략 구현
- [ ] 테스트 데이터 생성

### 데이터 무결성 및 분석
- [ ] 트랜잭션 관리 및 데이터 일관성
- [ ] 외래 키 제약 조건 및 정합성 검증
- [ ] 사용자 세그먼트 분석 (RFM 모델)
- [ ] 리스크 프로필 및 LTV 스코어 계산
- [ ] 실시간 데이터 업데이트 (Redis 캐시 활용)

### 데이터 마이그레이션
- [ ] Alembic 마이그레이션 스크립트
- [ ] 마이그레이션 테스트 및 검증
- [ ] 롤백 전략 및 비상 복구 계획
- [ ] 데이터 마이그레이션 가이드 문서화

## 5. 구입/서버 연동 (Purchase/Server Integration)
### 상점 및 결제 시스템
- [ ] 상점 상품 관리 및 표시 (Premium Gem, 패키지)
- [ ] 구매 로직 구현 (POST /api/shop/buy)
- [ ] 화폐 시스템 구현 (Regular Coins, Premium Gems)
- [ ] 한정 패키지 및 프로모션 관리

### 외부 결제 통합
- [ ] 외부 결제 서버 API 연동
- [ ] 결제 검증 및 보안 처리
- [ ] 웹훅/콜백 처리
- [ ] 결제 상태 추적 및 관리

### 트랜잭션 및 보상
- [ ] 구매 내역 기록 (shop_transactions)
- [ ] 구매 후 보상 지급 프로세스
- [ ] 가상화폐 잔액 관리 (Redis 캐시)
- [ ] 트랜잭션 일관성 및 동시성 제어

### 예외 처리 및 모니터링
- [ ] 결제 실패/취소/환불 처리 로직
- [ ] 트랜잭션 로그 및 감사
- [ ] 구매 패턴 모니터링 및 이상 감지
- [ ] 결제 관련 고객 지원 도구

---

## 6. 사용자 여정 단계별 통합 체크리스트
### 여정 1: 온보딩 및 첫 경험
- [ ] 랜딩 페이지 → 초대코드 → 회원가입 → 튜토리얼 흐름
- [ ] 첫 보상 및 성취 경험
- [ ] 네온 애니메이션 효과로 시각적 만족감
- [ ] 첫 게임 메커니즘 소개 (슬롯/가챠)
- [ ] 배틀패스/VIP 시스템 소개

### 여정 2: 참여 유도 및 습관화
- [ ] 일일/주간 보상 시스템
- [ ] 스트릭/연속 로그인 인센티브
- [ ] 게임 콘텐츠 확장 및 다양화
- [ ] 배틀패스 진행 시각화
- [ ] 소셜 증명 및 경쟁 요소

### 여정 3: 개인화 및 몰입
- [ ] RFM 세그먼트 기반 개인화 추천
- [ ] 사이버 토큰 소비/획득 미션
- [ ] 심리 퀴즈 기반 맞춤형 경험
- [ ] 알림을 통한 재참여 유도
- [ ] 사용자 행동 기반 피드백 강화

### 여정 4: 수익화 및 가치 제공
- [ ] 프리미엄 젬 구매 동기 부여
- [ ] 성인 콘텐츠 단계별 해금 경험
- [ ] VIP 등급 업그레이드 경로
- [ ] 한정 패키지 및 특별 프로모션
- [ ] 충성도 보상 및 혜택

### 여정 5: 유지 및 확장
- [ ] 이탈 방지 재참여 전략
- [ ] 신규 콘텐츠 및 기능 업데이트
- [ ] 커뮤니티 활동 및 상호작용
- [ ] 고객 피드백 수집 및 개선
- [ ] 장기 참여자 특별 혜택

---

## Kafka 최종 통합 및 검증 결과 (2025-07-29)

- Kafka Producer/Consumer가 정상적으로 연결 및 메시지 송수신을 수행함을 확인
- 로그에서 IPv6 환경에서도 문제없이 연결됨을 검증
- 실제 메시지 전송 및 종료까지 모든 단계에서 성공 로그 확인
- Casino-Club F2P 백엔드의 실시간 이벤트/액션 파이프라인이 정상적으로 동작함을 최종 검증
- 다음 단계: 실시간 피드백, 알림, 분석 이벤트 등 비즈니스 로직과의 통합 및 모니터링 대시보드 연동

```
INFO:kafka.conn:<BrokerConnection client_id=kafka-python-producer-1, node_id=bootstrap-0 host=localhost:9093 <connecting> [IPv6 ('::1', 9093, 0, 0)]>: connecting to localhost:9093 [('::1', 9093, 0, 0) IPv6]
INFO:kafka.conn:<BrokerConnection client_id=kafka-python-producer-1, node_id=bootstrap-0 host=localhost:9093 <checking_api_versions_recv> [IPv6 ('::1', 9093, 0, 0)]>: Broker version identified as 2.6
INFO:kafka.conn:<BrokerConnection client_id=kafka-python-producer-1, node_id=bootstrap-0 host=localhost:9093 <connected> [IPv6 ('::1', 9093, 0, 0)]>: Connection complete.
INFO:backend.app.core.kafka_client:✅ Kafka Producer 연결 성공
INFO:kafka.conn:<BrokerConnection client_id=kafka-python-producer-1, node_id=1 host=localhost:9093 <connecting> [IPv6 ('::1', 9093, 0, 0)]>: connecting to localhost:9093 [('::1', 9093, 0, 0) IPv6]
INFO:kafka.conn:<BrokerConnection client_id=kafka-python-producer-1, node_id=1 host=localhost:9093 <connected> [IPv6 ('::1', 9093, 0, 0)]>: Connection complete.
INFO:kafka.conn:<BrokerConnection client_id=kafka-python-producer-1, node_id=bootstrap-0 host=localhost:9093 <connected> [IPv6 ('::1', 9093, 0, 0)]>: Closing connection.
INFO:backend.app.core.kafka_client:✅ 사용자 액션 전송 성공: FINAL_VALIDATION for test_user_final
 Kafka 메시지 전송 성공!
INFO:kafka.producer.kafka:<KafkaProducer client_id=kafka-python-producer-1 transactional_id=None>: Closing the Kafka producer with 4294967.0 secs timeout.
INFO:kafka.conn:<BrokerConnection client_id=kafka-python-producer-1, node_id=1 host=localhost:9093 <connected> [IPv6 ('::1', 9093, 0, 0)]>: Closing connection.
INFO:backend.app.core.kafka_client:✅ Kafka Producer 연결 종료
```

---
**결론:**
- Casino-Club F2P 백엔드의 Kafka 실시간 메시징 인프라가 완전히 검증됨
- 실서비스 연동 및 확장에 적합한 구조로 안정화 완료


- [ ] 피드백 API (GET /api/feedback)
  - 체크 방법: 다양한 action_type으로 피드백 요청
  - 검증 기준: 감정 기반 피드백 메시지와 애니메이션 키 반환
  - 체크 대상:
    - [ ] 액션 유형별 피드백 매핑
    - [ ] 다국어 지원 (필요시)
    - [ ] 감정 기반 메시지 다양성
    - [ ] 애니메이션 키 및 효과 설정
    - [ ] 맥락 인식 메시지 (연속 액션)
    - [ ] A/B 테스트 지원 (다양한 피드백 스타일)

- [ ] 외부 결제 게이트웨이 연동 (Premium Gem)
  - 체크 방법: 다양한 결제 수단/금액으로 테스트 거래, 샌드박스 모드 검증
  - 검증 기준: 결제 프로세스 완료율 99.5%+, 평균 처리 시간 3초 이내
  - 체크 대상:
    - [ ] 결제 게이트웨이 API 통합
    - [ ] 다양한 결제 수단 지원 (신용카드, 가상계좌, 페이앱)
    - [ ] 결제 요청/응답 처리
    - [ ] 웹훅/콜백 처리
    - [ ] 결제 상태 추적
    - [ ] 에러 핸들링 및 재시도 메커니즘

- [ ] AdultContentStageComponent (Teaser, 부분 공개, 전체 공개)
  - 체크 방법: 각 단계별 콘텐츠 표시 확인, 해금 프로세스 테스트
  - 검증 기준: 단계별 적절한 콘텐츠 표시, 해금 조건 명시, 나이 제한 안내
  - 체크 대상:
    - [ ] 나이 확인 모달
    - [ ] 단계별 콘텐츠 미리보기
    - [ ] 해금 조건 표시 (토큰, 등급)
    - [ ] 해금 버튼 및 확인 모달
    - [ ] 콘텐츠 잠금/해제 상태 표시
    - [ ] 법적 고지사항 표시

 [ ] 유저 세그먼트 계산/업데이트 API (APScheduler)
  - 체크 방법: 배치 작업 실행 후 user_segments 테이블 변경 확인
  - 검증 기준: RFM 그룹이 사용자 행동에 따라 올바르게 분류됨
  - 체크 대상:
    - [ ] RFM 분석 알고리즘 (Recency, Frequency, Monetary)
    - [ ] 세그먼트 분류 로직 (Whale, High Engaged, Medium, Low/At-risk)
    - [ ] 배치 작업 스케줄링 (일일/주간 실행)
    - [ ] 성능 최적화 (대용량 사용자 처리)
    - [ ] 세그먼트 변경 히스토리 추적
    - [ ] 세그먼트 기반 타겟팅 로직

- [ ] 개인화 추천 API (GET /recommend/personalized)
  - 체크 방법: 다양한 세그먼트/리스크 프로필을 가진 사용자로 요청
  - 검증 기준: 세그먼트별 차별화된 추천 결과 반환
  - 체크 대상:
    - [ ] 세그먼트별 추천 규칙 엔진
    - [ ] 사이버 토큰 기반 미션 추천
    - [ ] 보상 제안 알고리즘
    - [ ] 리스크 프로필 기반 개인화
    - [ ] 추천 결과 랭킹 시스템
    - [ ] 추천 효과 추적 및 학습

- [ ] 심리 측정 퀴즈 제출/분석 API (POST /api/quiz/submit)
  - 체크 방법: 다양한 답변 패턴으로 퀴즈 제출
  - 검증 기준: 리스크 점수 계산 및 프로필 업데이트 정확성
  - 체크 대상:
    - [ ] 다단계 퀴즈 플로우
    - [ ] 심리 측정 모델 (위험 성향, 보상 반응성)
    - [ ] 점수 계산 알고리즘
    - [ ] 결과 해석 및 분류
    - [ ] 프로필 업데이트 로직
    - [ ] 퀴즈 결과 기반 개인화 적용




- [ ] VIP 등급 업그레이드 API
  - 체크 방법: 등급별 업그레이드 요건 충족/미충족 시나리오
  - 검증 기준: 등급에 따른 혜택 적용, 업그레이드 히스토리 기록
  - 체크 대상:
    - [ ] 등급별 요구 조건 정의 (소비 금액, 활동 점수)
    - [ ] 자동/수동 업그레이드 로직
    - [ ] 등급별 혜택 설정 (할인율, 전용 콘텐츠)
    - [ ] 등급 다운그레이드 정책
    - [ ] VIP 전용 기능 접근 제어
    - [ ] 등급 변경 알림 시스템---

 [ ] 심리 측정 퀴즈 UI (다단계 질문)
  - 체크 방법: 전체 퀴즈 플로우 완주, 다양한 답변 패턴 테스트
  - 검증 기준: 진행률 표시, 결과 페이지 표시, 결과 기반 개인화 적용
  - 체크 대상:
    - [ ] 단계별 질문 표시
    - [ ] 진행률 바 및 페이지네이션
    - [ ] 답변 선택 인터페이스
    - [ ] 결과 분석 및 시각화
    - [ ] 퀴즈 재시도 옵션
    - [ ] 결과 공유 기능




## 🎮 게임 API 연동 및 프로필 통합 가이드 (우선순위 5)

### 개요
프로필 페이지에서 사용자의 모든 게임 활동, 통계, 보상 내역을 실시간으로 확인할 수 있도록 하는 통합 시스템 구축

### 1. 게임 API 엔드포인트 설계

#### 1.1 게임 통계 조회 API
```python
# /api/games/stats/{user_id}
@router.get("/games/stats/{user_id}")
async def get_game_stats(
    user_id: int,
    game_type: Optional[str] = None,  # 'slot', 'poker', 'blackjack', 'all'
    period: str = "week",  # 'day', 'week', 'month', 'all'
    db: Session = Depends(get_db)
) -> GameStatsResponse:
    """
    사용자 게임 통계 조회
    - 총 게임 수, 승률, 수익률
    - 선호 게임, 플레이 시간
    - 최고 기록, 연승 기록
    """
```

#### 1.2 실시간 게임 세션 API
```python
# /api/games/session/{user_id}/current
@router.get("/games/session/{user_id}/current")
async def get_current_game_session(user_id: int):
    """현재 진행중인 게임 세션 정보"""

# /api/games/session/start
@router.post("/games/session/start")
async def start_game_session(game_data: GameSessionStart):
    """게임 세션 시작"""

# /api/games/session/end
@router.post("/games/session/end")
async def end_game_session(session_data: GameSessionEnd):
    """게임 세션 종료 및 결과 저장"""
```

#### 1.3 보상 및 업적 API
```python
# /api/games/achievements/{user_id}
@router.get("/games/achievements/{user_id}")
async def get_user_achievements(user_id: int):
    """사용자 업적 및 보상 내역"""

# /api/games/leaderboard
@router.get("/games/leaderboard")
async def get_leaderboard(
    game_type: str,
    period: str = "week",
    limit: int = 10
):
    """게임별 리더보드"""
```

### 2. 프론트엔드 통합 컴포넌트

#### 2.1 GameStatsWidget 컴포넌트
```tsx
// components/profile/GameStatsWidget.tsx
interface GameStatsWidgetProps {
  userId: number;
  gameType?: string;
}

export function GameStatsWidget({ userId, gameType }: GameStatsWidgetProps) {
  const [stats, setStats] = useState<GameStats | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchGameStats = async () => {
      try {
        const response = await fetch(`/api/games/stats/${userId}?game_type=${gameType}`);
        const data = await response.json();
        setStats(data);
      } catch (error) {
        console.error('게임 통계 로드 실패:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchGameStats();
    
    // 실시간 업데이트를 위한 WebSocket 연결
    const ws = new WebSocket(`ws://localhost:8000/ws/game-stats/${userId}`);
    ws.onmessage = (event) => {
      const updatedStats = JSON.parse(event.data);
      setStats(updatedStats);
    };

    return () => ws.close();
  }, [userId, gameType]);

  return (
    <div className="game-stats-widget">
      {/* 게임 통계 UI */}
    </div>
  );
}
```

#### 2.2 실시간 게임 현황 컴포넌트
```tsx
// components/profile/LiveGameStatus.tsx
export function LiveGameStatus({ userId }: { userId: number }) {
  const [currentSession, setCurrentSession] = useState<GameSession | null>(null);

  return (
    <div className="live-game-status">
      {currentSession ? (
        <div className="bg-green-500/20 border border-green-500/30 rounded-xl p-4">
          <div className="flex items-center gap-2">
            <div className="w-3 h-3 bg-green-500 rounded-full animate-pulse" />
            <span className="text-green-400 font-semibold">게임 진행중</span>
          </div>
          <div className="mt-2 text-white">
            <div>게임: {currentSession.gameType}</div>
            <div>경과 시간: {formatDuration(currentSession.duration)}</div>
            <div>현재 베팅: {currentSession.currentBet.toLocaleString()} 토큰</div>
          </div>
        </div>
      ) : (
        <div className="bg-gray-600/20 border border-gray-500/30 rounded-xl p-4">
          <span className="text-gray-400">현재 게임 없음</span>
        </div>
      )}
    </div>
  );
}
```

### 3. 데이터베이스 스키마 확장

#### 3.1 게임 세션 테이블
```sql
CREATE TABLE game_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id INTEGER NOT NULL REFERENCES users(id),
    game_type VARCHAR(50) NOT NULL,
    game_variant VARCHAR(50), -- 게임 변형 (예: texas_holdem, european_roulette)
    start_time TIMESTAMP DEFAULT NOW(),
    end_time TIMESTAMP,
    initial_balance INTEGER NOT NULL,
    final_balance INTEGER,
    total_bet INTEGER DEFAULT 0,
    total_win INTEGER DEFAULT 0,
    net_result INTEGER DEFAULT 0,
    max_bet INTEGER DEFAULT 0,
    hand_count INTEGER DEFAULT 0, -- 총 핸드/스핀 수
    win_count INTEGER DEFAULT 0,
    session_data JSONB, -- 게임별 상세 데이터
    status VARCHAR(20) DEFAULT 'active', -- active, completed, disconnected
    ip_address INET,
    user_agent TEXT
);

CREATE INDEX idx_game_sessions_user_time ON game_sessions(user_id, start_time);
CREATE INDEX idx_game_sessions_type ON game_sessions(game_type, start_time);
```

#### 3.2 게임 핸드/라운드 상세 테이블
```sql
CREATE TABLE game_hands (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL REFERENCES game_sessions(id),
    hand_number INTEGER NOT NULL,
    game_type VARCHAR(50) NOT NULL,
    bet_amount INTEGER NOT NULL,
    win_amount INTEGER DEFAULT 0,
    hand_data JSONB, -- 카드, 주사위, 슬롯 결과 등
    hand_result VARCHAR(50), -- win, lose, push, bonus
    timestamp TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_game_hands_session ON game_hands(session_id, hand_number);
```

#### 3.3 업적 및 배지 테이블
```sql
CREATE TABLE achievements (
    id SERIAL PRIMARY KEY,
    achievement_key VARCHAR(100) UNIQUE NOT NULL,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    badge_icon VARCHAR(100),
    badge_color VARCHAR(50),
    requirements JSONB, -- 달성 조건
    reward_tokens INTEGER DEFAULT 0,
    reward_items JSONB,
    is_active BOOLEAN DEFAULT true
);

CREATE TABLE user_achievements (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id),
    achievement_id INTEGER NOT NULL REFERENCES achievements(id),
    achieved_at TIMESTAMP DEFAULT NOW(),
    progress_data JSONB, -- 달성 과정 데이터
    
    UNIQUE(user_id, achievement_id)
);
```

### 4. 실시간 업데이트 (WebSocket)

#### 4.1 WebSocket 연결 관리
```python
# websocket_manager.py
class GameStatsWebSocketManager:
    def __init__(self):
        self.active_connections: Dict[int, List[WebSocket]] = {}

    async def connect(self, websocket: WebSocket, user_id: int):
        await websocket.accept()
        if user_id not in self.active_connections:
            self.active_connections[user_id] = []
        self.active_connections[user_id].append(websocket)

    async def disconnect(self, websocket: WebSocket, user_id: int):
        if user_id in self.active_connections:
            self.active_connections[user_id].remove(websocket)

    async def send_stats_update(self, user_id: int, stats_data: dict):
        if user_id in self.active_connections:
            for connection in self.active_connections[user_id]:
                try:
                    await connection.send_json(stats_data)
                except ConnectionClosedOK:
                    await self.disconnect(connection, user_id)

# WebSocket 엔드포인트
@app.websocket("/ws/game-stats/{user_id}")
async def websocket_endpoint(websocket: WebSocket, user_id: int):
    await manager.connect(websocket, user_id)
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        await manager.disconnect(websocket, user_id)
```

### 5. 프로필 페이지 통합

#### 5.1 ProfileContainer 확장
```tsx
// ProfileContainer.tsx 수정
export default function ProfileContainer() {
  const { user } = useUser();
  const [gameStats, setGameStats] = useState<GameStats | null>(null);
  const [achievements, setAchievements] = useState<Achievement[]>([]);

  return (
    <div className="profile-container">
      <ProfileHeader user={user} />
      <ProfileStats user={user} gameStats={gameStats} />
      
      {/* 새로운 게임 통계 섹션 */}
      <GameStatsWidget userId={user.id} />
      <LiveGameStatus userId={user.id} />
      <AchievementsPanel achievements={achievements} />
      
      <MissionCards missions={missions} />
    </div>
  );
}
```

### 6. 구현 우선순위

#### Phase 1: 기본 게임 통계 (1-2주)
- [ ] 게임 세션 테이블 생성
- [ ] 기본 게임 통계 API 구현
- [ ] ProfileStats에 게임 데이터 연동
- [ ] 실시간 토큰 잔액 업데이트

#### Phase 2: 상세 게임 데이터 (2-3주)
- [ ] 게임별 상세 통계 구현
- [ ] 게임 핸드 데이터 저장
- [ ] 승률, 수익률 계산 로직
- [ ] 게임 히스토리 조회 기능

#### Phase 3: 실시간 기능 (3-4주)
- [ ] WebSocket 연동
- [ ] 실시간 게임 세션 모니터링
- [ ] 라이브 통계 업데이트
- [ ] 푸시 알림 연동

#### Phase 4: 업적 및 보상 (4-5주)
- [ ] 업적 시스템 구현
- [ ] 배지 및 보상 UI
- [ ] 리더보드 기능
- [ ] 소셜 기능 (친구, 공유)

### 7. 테스트 전략

#### 7.1 단위 테스트
```python
# test_game_stats.py
def test_calculate_win_rate():
    """승률 계산 로직 테스트"""
    
def test_session_creation():
    """게임 세션 생성 테스트"""
    
def test_achievement_unlock():
    """업적 해금 조건 테스트"""
```

#### 7.2 통합 테스트
```python
# test_game_integration.py
def test_game_to_profile_integration():
    """게임 API와 프로필 연동 테스트"""
    
def test_websocket_real_time_updates():
    """WebSocket 실시간 업데이트 테스트"""
```

### 8. 모니터링 및 성능

#### 8.1 성능 메트릭
- API 응답 시간 (< 200ms 목표)
- WebSocket 연결 안정성
- 데이터베이스 쿼리 최적화
- 실시간 업데이트 지연시간

#### 8.2 모니터링 대시보드
- 게임 세션 수 (실시간)
- 평균 플레이 시간
- 게임별 인기도
- 사용자 참여도 지표

이 가이드를 통해 프로필 페이지가 단순한 정보 표시를 넘어 사용자의 모든 게임 활동을 통합 관리하는 허브가 되도록 구현할 수 있습니다.

---

## [2025-08-11] 안정화 업데이트: Kafka 라운드트립, CI 마이그레이션 검증, 테스트 하이진

변경 요약
- Kafka 라운드트립 테스트를 debug/peek 엔드포인트 기반으로 전환해 비결정성 제거. in-process 버퍼 의존 없이 브로커에서 직접 읽어 단정. 대상 파일: `app/tests/test_kafka_roundtrip.py`.
- CI 워크플로우에 Alembic history 출력과 명시적 downgrade(-1 허용)/upgrade head 단계를 추가해 마이그레이션 안전성 확보. 대상 파일: `.github/workflows/ci.yml`.
- CI 필수 게이트를 최소 그린 경로 테스트로 한정: `app/tests/test_user_journey.py`, `app/tests/test_kafka_roundtrip.py`.
- 테스트 하이진: pytest.ini에서 `--ignore=tests` 유지로 중복 경로 수집 차단. 레거시 `tests/`는 점진 보수 후 재활성화 예정.

검증 결과
- 컨테이너 내부:
  - `alembic heads` → [현재 리포 상태 기준] 리비전 메타 누락으로 실패. 단일 head 복구 필요.
  - `pytest -q app/tests/test_user_journey.py` → PASS
  - `pytest -q app/tests/test_kafka_roundtrip.py` → debug/peek 기반 라운드트립 PASS (브로커 활성 시)
- OpenAPI 재수출 완료 (`cc-webapp/backend/current_openapi.json`).

다음 단계
- Kafka 전용 격리 토픽(KAFKA_TEST_TOPIC=cc_test_ci)로 CI 간 간섭 방지 강화 및 토픽 자동생성 상태 확인.
- 레거시 `tests/` 경로의 import/스키마 불일치 수정 후 마이그레이션, games, auth 테스트 점진적 재활성화.
- Alembic explicit downgrade 대상 리비전을 고정(merge 토폴로지 고려)하고 이력 그래프 자동 점검 스크립트 추가.

---

## [2025-08-11] 런북 재검증 및 Alembic 스키마 인식 마이그레이션 적용

변경 요약
- CI 테스트 스택 기동 시 ZooKeeper/Kafka 서비스를 함께 시작하도록 업데이트(.github/workflows/ci.yml)해 카프카 기반 테스트 안정화.
- Alembic 리비전 20250811_core_ix를 스키마 인식(schema-aware) 방식으로 수정. 존재하는 테이블/컬럼만 인덱스·제약을 생성하고, user_actions.created_at/timestamp 등 환경차를 안전 처리. user_game_stats/game_stats 양자 호환 유니크 제약 생성.
- 컨테이너 내부 기준 런북 수행: 마이그레이션 적용, OpenAPI 재수출, 스모크/저니 테스트 실행.

검증 결과
- 컨테이너 상태: postgres/redis/zookeeper/kafka/backend 모두 Up(healthy). 테스트용 zookeeper_test/kafka_test도 기동 확인.
- Alembic: [현재 리포 상태 기준] heads 실행 실패(리비전 메타 누락). 보정 후 단일 head 복구 예정.
- OpenAPI: current_openapi.json 재생성 성공.
- 테스트: app/tests/test_smoke_health.py, app/tests/test_user_journey.py 통과.

다음 단계
- CI에서 Kafka 라운드트립 테스트를 플래그(KAFKA_ENABLED)로 옵션화하여 환경 의존성 완화, 격리 토픽(KAFKA_TEST_TOPIC) 고정 유지.
- Pydantic v2 경고 제거(ConfigDict 전환, protected_namespaces 충돌 해소).
- 트랜잭션/ACID 범위 테스트 확장 및 백업/복구 자동 검증 추가.

---