20250807
📋 현재 상황 분석
프로젝트 구조를 분석한 결과, 다음과 같은 주요 이슈들이 확인되었습니다:

1. 백엔드 구조 문제
중복 파일 다수 존재:
인증 시스템: auth.py, auth_simple.py, auth_clean.py, auth_temp.py 등
메인 앱: main.py, main_simple.py, main_fixed.py
설정 파일: config.py, config_simple.py
게임 라우터: games.py, games_fixed.py, games_direct.py, game_api.py, game_api_v2.py
2. API 통합 문제
백엔드와 프론트엔드 간의 API 연동이 완전하지 않음
엔드포인트 구조의 일관성 부족
인증 시스템의 복잡성
🚀 단계별 해결 방안
Phase 1: 백엔드 구조 정리 (1-2일)
1.1 중복 파일 정리
# 백업 디렉토리 생성
New-Item -ItemType Directory -Force -Path "cc-webapp\backend\app\_backup_$(Get-Date -Format 'yyyyMMdd')"

# 중복 파일들을 백업 폴더로 이동
Move-Item -Path @(
    "cc-webapp\backend\app\main_simple.py",
    "cc-webapp\backend\app\main_fixed.py",
    "cc-webapp\backend\app\config_simple.py",
    "cc-webapp\backend\app\routers\auth_simple.py",
    "cc-webapp\backend\app\routers\auth_clean.py",
    "cc-webapp\backend\app\routers\auth_temp.py",
    "cc-webapp\backend\app\routers\games_fixed.py",
    "cc-webapp\backend\app\routers\games_direct.py",
    "cc-webapp\backend\app\routers\game_api.py"
) -Destination "cc-webapp\backend\app\_backup_$(Get-Date -Format 'yyyyMMdd')" -Force

1.2 통합된 메인 설정 파일
"""통합 설정 모듈"""
import os
from typing import Optional, List
from pydantic_settings import BaseSettings
from pydantic import Field

class Settings(BaseSettings):
    """Casino-Club F2P 통합 설정"""
    
    # 기본 설정
    app_name: str = "Casino-Club F2P"
    app_version: str = "1.0.0"
    debug: bool = Field(default=False, env="DEBUG")
    
    # 데이터베이스 설정
    database_url: str = Field(
        default="postgresql://cc_user:cc_password@postgres:5432/cc_webapp",
        env="DATABASE_URL"
    )
    
    # JWT 설정
    jwt_secret_key: str = Field(
        default="your-secret-key-change-in-production",
        env="JWT_SECRET_KEY"
    )
    jwt_algorithm: str = "HS256"
    jwt_access_token_expire_minutes: int = 30
    jwt_refresh_token_expire_days: int = 7
    
    # Redis 설정
    redis_url: str = Field(
        default="redis://redis:6379/0",
        env="REDIS_URL"
    )
    
    # CORS 설정
    cors_origins: List[str] = Field(
        default=["http://localhost:3000", "http://localhost:8000"],
        env="CORS_ORIGINS"
    )
    
    # 초대 코드 설정
    require_invite_code: bool = True
    master_invite_code: str = "CASINO2025"
    
    # 게임 설정
    initial_coins: int = 1000
    initial_gems: int = 10
    daily_bonus_coins: int = 100
    
    class Config:
        env_file = ".env"
        case_sensitive = False

settings = Settings()


Phase 2: API 엔드포인트 표준화 (2-3일)
2.1 통합 라우터 구조
"""API v1 라우터 통합"""
from fastapi import APIRouter
from app.api.v1 import auth, users, games, shop, missions, events

api_router = APIRouter(prefix="/api/v1")

# 핵심 라우터 등록
api_router.include_router(auth.router, prefix="/auth", tags=["authentication"])
api_router.include_router(users.router, prefix="/users", tags=["users"])
api_router.include_router(games.router, prefix="/games", tags=["games"])
api_router.include_router(shop.router, prefix="/shop", tags=["shop"])
api_router.include_router(missions.router, prefix="/missions", tags=["missions"])
api_router.include_router(events.router, prefix="/events", tags=["events"])



🎮 Casino-Club F2P 프로젝트 통합 개발 가이드
📋 현재 상황 분석
프로젝트 구조를 분석한 결과, 다음과 같은 주요 이슈들이 확인되었습니다:

1. 백엔드 구조 문제
중복 파일 다수 존재:
인증 시스템: auth.py, auth_simple.py, auth_clean.py, auth_temp.py 등
메인 앱: main.py, main_simple.py, main_fixed.py
설정 파일: config.py, config_simple.py
게임 라우터: games.py, games_fixed.py, games_direct.py, game_api.py, game_api_v2.py
2. API 통합 문제
백엔드와 프론트엔드 간의 API 연동이 완전하지 않음
엔드포인트 구조의 일관성 부족
인증 시스템의 복잡성
🚀 단계별 해결 방안
Phase 1: 백엔드 구조 정리 (1-2일)
1.1 중복 파일 정리
1.2 통합된 메인 설정 파일

Phase 2: API 엔드포인트 표준화 (2-3일)
2.1 통합 라우터 구조
2.2 표준화된 인증 시스템

"""통합 인증 API"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import timedelta
from app.core.database import get_db
from app.core.security import create_access_token, verify_password, get_password_hash
from app.schemas.auth import LoginRequest, SignupRequest, TokenResponse
from app.models.user import User
from app.core.config import settings

router = APIRouter()

@router.post("/signup", response_model=TokenResponse)
async def signup(
    request: SignupRequest,
    db: Session = Depends(get_db)
):
    """초대 코드 기반 회원가입"""
    # 초대 코드 검증
    if settings.require_invite_code:
        if request.invite_code != settings.master_invite_code:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid invite code"
            )
    
    # 중복 체크
    existing_user = db.query(User).filter(
        User.nickname == request.nickname
    ).first()
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Nickname already exists"
        )
    
    # 사용자 생성
    user = User(
        nickname=request.nickname,
        password_hash=get_password_hash(request.password),
        coins=settings.initial_coins,
        gems=settings.initial_gems
    )
    db.add(user)
    db.commit()
    db.refresh(user)
    
    # 토큰 생성
    access_token = create_access_token(
        data={"sub": str(user.id)},
        expires_delta=timedelta(minutes=settings.jwt_access_token_expire_minutes)
    )
    
    return TokenResponse(
        access_token=access_token,
        token_type="bearer",
        user_id=user.id,
        nickname=user.nickname
    )

@router.post("/login", response_model=TokenResponse)
async def login(
    request: LoginRequest,
    db: Session = Depends(get_db)
):
    """로그인"""
    user = db.query(User).filter(
        User.nickname == request.nickname
    ).first()
    
    if not user or not verify_password(request.password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials"
        )
    
    access_token = create_access_token(
        data={"sub": str(user.id)},
        expires_delta=timedelta(minutes=settings.jwt_access_token_expire_minutes)
    )
    
    return TokenResponse(
        access_token=access_token,
        token_type="bearer",
        user_id=user.id,
        nickname=user.nickname
    )

Phase 3: 프론트엔드 API 통합 (2-3일)
3.1 API 클라이언트 통합


/**
 * 통합 API 클라이언트
 */
import axios, { AxiosInstance } from 'axios';
import { getToken, removeToken } from '../auth/tokenStorage';

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000/api/v1';

class ApiClient {
    private client: AxiosInstance;

    constructor() {
        this.client = axios.create({
            baseURL: API_BASE_URL,
            timeout: 10000,
            headers: {
                'Content-Type': 'application/json',
            },
        });

        // 요청 인터셉터
        this.client.interceptors.request.use(
            (config) => {
                const token = getToken();
                if (token) {
                    config.headers.Authorization = `Bearer ${token}`;
                }
                return config;
            },
            (error) => Promise.reject(error)
        );

        // 응답 인터셉터
        this.client.interceptors.response.use(
            (response) => response,
            async (error) => {
                if (error.response?.status === 401) {
                    removeToken();
                    window.location.href = '/login';
                }
                return Promise.reject(error);
            }
        );
    }

    // 인증 API
    async signup(nickname: string, password: string, inviteCode: string) {
        const response = await this.client.post('/auth/signup', {
            nickname,
            password,
            invite_code: inviteCode,
        });
        return response.data;
    }

    async login(nickname: string, password: string) {
        const response = await this.client.post('/auth/login', {
            nickname,
            password,
        });
        return response.data;
    }

    // 사용자 API
    async getUserProfile(userId: string) {
        const response = await this.client.get(`/users/${userId}`);
        return response.data;
    }

    // 게임 API
    async playSlot(betAmount: number) {
        const response = await this.client.post('/games/slot/spin', {
            bet_amount: betAmount,
        });
        return response.data;
    }

    async playRPS(choice: string, betAmount: number) {
        const response = await this.client.post('/games/rps/play', {
            choice,
            bet_amount: betAmount,
        });
        return response.data;
    }

    // 상점 API
    async getShopItems() {
        const response = await this.client.get('/shop/items');
        return response.data;
    }

    async purchaseItem(itemId: string) {
        const response = await this.client.post(`/shop/purchase/${itemId}`);
        return response.data;
    }
}

export default new ApiClient();



Phase 4: Docker 환경 통합 (1일)
4.1 통합 Docker Compose 설정


version: '3.8'

services:
  backend:
    build: 
      context: ./cc-webapp/backend
      dockerfile: Dockerfile
    container_name: cc_backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://cc_user:cc_password@postgres:5432/cc_webapp
      - REDIS_URL=redis://redis:6379/0
      - JWT_SECRET_KEY=${JWT_SECRET_KEY:-development-secret-key}
      - DEBUG=${DEBUG:-false}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./cc-webapp/backend:/app
      - ./logs/backend:/app/logs
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

  frontend:
    build:
      context: ./cc-webapp/frontend
      dockerfile: Dockerfile
    container_name: cc_frontend
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_API_URL=http://localhost:8000/api/v1
    depends_on:
      - backend
    volumes:
      - ./cc-webapp/frontend:/app
      - /app/node_modules
      - /app/.next

  postgres:
    image: postgres:14-alpine
    container_name: cc_postgres
    environment:
      - POSTGRES_USER=cc_user
      - POSTGRES_PASSWORD=cc_password
      - POSTGRES_DB=cc_webapp
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init:/docker-entrypoint-initdb.d
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U cc_user"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: cc_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
  redis_data:


📝 테스트 체크리스트
Backend API 테스트

# 1. 헬스체크
curl http://localhost:8000/health

# 2. 회원가입 테스트
curl -X POST http://localhost:8000/api/v1/auth/signup \
  -H "Content-Type: application/json" \
  -d '{"nickname":"testuser","password":"test123","invite_code":"CASINO2025"}'

# 3. 로그인 테스트
curl -X POST http://localhost:8000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"nickname":"testuser","password":"test123"}'

# 4. 게임 API 테스트 (토큰 필요)
curl -X POST http://localhost:8000/api/v1/games/slot/spin \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"bet_amount":100}'


Frontend 통합 테스트
로그인 페이지 (http://localhost:3000/login)
회원가입 플로우
게임 실행 (슬롯, RPS)
상점 구매
미션/이벤트 확인
🔧 문제 해결 가이드
일반적인 문제들
1. CORS 오류
# backend/app/main.py에 CORS 설정 확인
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
2. 데이터베이스 연결 오류

# PostgreSQL 컨테이너 확인
docker ps | grep postgres
docker logs cc_postgres

# 데이터베이스 직접 접속 테스트
docker exec -it cc_postgres psql -U cc_user -d cc_webapp

3. 프론트엔드 API 연결 오류
// .env.local 파일 확인
NEXT_PUBLIC_API_URL=http://localhost:8000/api/v1

🚀 다음 단계 액션 플랜
즉시 실행 (Day 1)
✅ 백업 디렉토리 생성 및 중복 파일 이동
✅ 통합 설정 파일 생성
✅ Docker 환경 재시작
단기 (Day 2-3)
✅ API 엔드포인트 표준화
✅ 인증 시스템 통합
✅ 프론트엔드 API 클라이언트 통합
중기 (Day 4-7)
✅ 전체 기능 테스트
✅ 버그 수정 및 최적화
✅ 문서 업데이트
📚 참고 문서
CASINO_CLUB_F2P_INTEGRATION_CHECKLIST.md
PHASE1_API_INTEGRATION_TEST_REPORT.md
DATABASE_CONNECTION_GUIDE.md
이 가이드를 따라 진행하면 현재의 중복 파일 문제를 해결하고, 깔끔한 API 통합 구조를 구축할 수 있습니다. 
각 단계별로 테스트를 진행하며, 문제가 발생하면 즉시 해결하는 것이 중요합니다.


---------------------------------------
🔍 프로젝트 구조 분석 및 문제점 진단
1. Docker 환경 파일 중복 문제
프로젝트 루트에 다수의 Docker 관련 파일이 산재되어 있습니다:

docker-compose.yml (메인)
docker-compose.basic.yml
docker-compose.dev.yml  
docker-compose.prod.yml
docker-compose.staging.yml
docker-compose.override.yml
docker-compose-example.yml

문제점:

어떤 파일이 실제로 사용되는지 불명확
환경별 설정이 중복되거나 충돌 가능성
유지보수 어려움
2. 환경 변수 파일 중복
|
.env.development
.env.production
.env.staging
.env.example
.env.jules


문제점:

환경별 설정 관리 혼란
실제 사용 파일 불명확
3. 백엔드 구조 문제
config_simple.py를 보면:

Pydantic v1 스타일 사용 (BaseSettings)
환경 변수 직접 읽기 (os.getenv) - Pydantic의 자동 로딩 미활용
4. 프론트엔드-백엔드 기능 불일치
문서(27_async_sync_status_analysis.md)에 따르면:

프론트엔드에서 실제 백엔드 API 호출 누락
슬롯머신 등이 시뮬레이션만 동작
5. 스크립트 파일 난립

cc-manage.ps1
docker-manage.ps1
dev-tools.ps1
diagnose-frontend.ps1
deploy-auth-fix.ps1
debug-auth-environment.ps1

📋 전수 검사 체크리스트
Docker 환경 정리

# Docker 환경 파일 전수 검사 스크립트

Write-Host "🔍 Docker 환경 파일 검사 시작..." -ForegroundColor Cyan

# Docker Compose 파일 찾기
$dockerFiles = Get-ChildItem -Path . -Filter "docker-compose*.yml" -File
Write-Host "`n📁 발견된 Docker Compose 파일:" -ForegroundColor Yellow
$dockerFiles | ForEach-Object { 
    Write-Host "  - $($_.Name) ($(Get-Date $_.LastWriteTime -Format 'yyyy-MM-dd'))" 
}

# 실제 사용 중인 파일 확인
Write-Host "`n✅ 권장 구조:" -ForegroundColor Green
Write-Host "  - docker-compose.yml (기본)"
Write-Host "  - docker-compose.override.yml (개발 오버라이드)"
Write-Host "  - docker-compose.prod.yml (프로덕션)"

# 환경 변수 파일 검사
$envFiles = Get-ChildItem -Path . -Filter ".env*" -File
Write-Host "`n📁 발견된 환경 변수 파일:" -ForegroundColor Yellow
$envFiles | ForEach-Object { 
    Write-Host "  - $($_.Name)"
}

# 백엔드 구조 검사
Write-Host "`n🔍 백엔드 구조 검사..." -ForegroundColor Cyan
$backendPath = "cc-webapp/backend/app"
if (Test-Path $backendPath) {
    $backendStructure = @{
        "routers" = (Get-ChildItem "$backendPath/routers" -Filter "*.py" 2>$null).Count
        "services" = (Get-ChildItem "$backendPath/services" -Filter "*.py" 2>$null).Count
        "models" = (Get-ChildItem "$backendPath/models" -Filter "*.py" 2>$null).Count
        "schemas" = (Get-ChildItem "$backendPath/schemas" -Filter "*.py" 2>$null).Count
    }
    
    Write-Host "백엔드 모듈 수:"
    $backendStructure.GetEnumerator() | ForEach-Object {
        Write-Host "  - $($_.Key): $($_.Value) 파일"
    }
}

# 프론트엔드 구조 검사
Write-Host "`n🔍 프론트엔드 구조 검사..." -ForegroundColor Cyan
$frontendPath = "cc-webapp/frontend"
if (Test-Path $frontendPath) {
    $frontendStructure = @{
        "app pages" = (Get-ChildItem "$frontendPath/app" -Filter "*.tsx" -Recurse 2>$null).Count
        "components" = (Get-ChildItem "$frontendPath/components" -Filter "*.tsx" -Recurse 2>$null).Count
        "API calls" = (Select-String -Path "$frontendPath/**/*.tsx","$frontendPath/**/*.ts" -Pattern "fetch|axios|apiClient" -Recurse 2>$null).Count
    }
    
    Write-Host "프론트엔드 구조:"
    $frontendStructure.GetEnumerator() | ForEach-Object {
        Write-Host "  - $($_.Key): $($_.Value)"
    }
}



통합 Docker Compose 설정

# 메인 Docker Compose 설정 (통합 버전)
version: '3.8'

services:
  backend:
    build:
      context: ./cc-webapp/backend
      dockerfile: Dockerfile
    container_name: cc_backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://cc_user:cc_password@postgres:5432/cc_webapp
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET_KEY=${JWT_SECRET_KEY:-dev-secret-key}
    depends_on:
      - postgres
      - redis
    volumes:
      - ./cc-webapp/backend:/app
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

  frontend:
    build:
      context: ./cc-webapp/frontend
      dockerfile: Dockerfile
    container_name: cc_frontend
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_API_URL=http://localhost:8000
    depends_on:
      - backend
    volumes:
      - ./cc-webapp/frontend:/app
      - /app/node_modules
      - /app/.next

  postgres:
    image: postgres:14-alpine
    container_name: cc_postgres
    environment:
      - POSTGRES_USER=cc_user
      - POSTGRES_PASSWORD=cc_password
      - POSTGRES_DB=cc_webapp
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    container_name: cc_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:


  백엔드 Config 개선


# 개선된 설정 모듈
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import Optional
from functools import lru_cache

class Settings(BaseSettings):
    """애플리케이션 설정 (Pydantic v2)"""
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False
    )
    
    # Database
    database_url: str = "postgresql://cc_user:cc_password@localhost:5432/cc_webapp"
    
    # Redis
    redis_url: str = "redis://localhost:6379"
    
    # JWT
    jwt_secret_key: str = "super-secret-key-for-development-only"
    jwt_algorithm: str = "HS256"
    jwt_access_token_expire_minutes: int = 30
    
    # API
    api_version: str = "0.1.0"
    debug: bool = False
    
    # Admin
    default_admin_username: str = "admin"
    default_admin_password: str = "admin"
    
    # CORS
    cors_origins: list[str] = ["http://localhost:3000"]

@lru_cache()
def get_settings() -> Settings:
    """설정 싱글톤 인스턴스 반환"""
    return Settings()

settings = get_settings()


프론트엔드 API 연결 검증
// API 클라이언트 통합
import axios from 'axios';

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';

export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  withCredentials: true,
});

// 토큰 인터셉터
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('access_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 에러 인터셉터
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // 토큰 만료 처리
      localStorage.removeItem('access_token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

// API 엔드포인트
export const api = {
  // 게임 API
  games: {
    slotSpin: (betAmount: number) => 
      apiClient.post('/api/games/slot/spin', { bet_amount: betAmount }),
    rouletteSpin: (betType: string, betValue: any) => 
      apiClient.post('/api/games/roulette/spin', { bet_type: betType, bet_value: betValue }),
    gachaPull: (pullType: string) => 
      apiClient.post('/api/games/gacha/pull', { pull_type: pullType }),
  },
  
  // 유저 API
  users: {
    getProfile: () => apiClient.get('/api/users/profile'),
    updateProfile: (data: any) => apiClient.patch('/api/users/profile', data),
  },
  
  // 토큰 API
  tokens: {
    getBalance: () => apiClient.get('/api/tokens/balance'),
    purchase: (amount: number) => apiClient.post('/api/tokens/purchase', { amount }),
  },
};


환경 통합 스크립트

# 환경 정리 및 통합 스크립트

Write-Host "🧹 프로젝트 환경 정리 시작..." -ForegroundColor Green

# 1. 불필요한 Docker Compose 파일 백업
$backupDir = "backups/docker-configs-$(Get-Date -Format 'yyyyMMdd')"
New-Item -ItemType Directory -Path $backupDir -Force | Out-Null

@("docker-compose.basic.yml", "docker-compose-example.yml") | ForEach-Object {
    if (Test-Path $_) {
        Move-Item $_ "$backupDir/" -Force
        Write-Host "  ✅ $_ 백업 완료" -ForegroundColor Yellow
    }
}

# 2. 환경 변수 파일 정리
Write-Host "`n📁 환경 변수 파일 통합..." -ForegroundColor Cyan

# .env.development를 기본 .env로
if (Test-Path ".env.development") {
    Copy-Item ".env.development" ".env" -Force
    Write-Host "  ✅ .env 파일 생성 완료" -ForegroundColor Green
}

# 3. 프론트엔드-백엔드 연결 확인
Write-Host "`n🔗 API 연결 상태 확인..." -ForegroundColor Cyan

# Docker 서비스 시작
docker-compose up -d postgres redis
Start-Sleep -Seconds 5

# 백엔드 테스트
$backendHealth = Invoke-RestMethod -Uri "http://localhost:8000/health" -Method Get -ErrorAction SilentlyContinue
if ($backendHealth) {
    Write-Host "  ✅ 백엔드 API 정상" -ForegroundColor Green
} else {
    Write-Host "  ❌ 백엔드 API 응답 없음" -ForegroundColor Red
}

# 4. 통합 보고서 생성
$report = @"
# 환경 통합 보고서
생성일: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')

## Docker 환경
- 메인 파일: docker-compose.yml
- 개발 오버라이드: docker-compose.override.yml
- 프로덕션: docker-compose.prod.yml

## 환경 변수
- 개발: .env (기본)
- 프로덕션: .env.production
- 예제: .env.example

## 서비스 상태
- Backend: http://localhost:8000
- Frontend: http://localhost:3000
- PostgreSQL: localhost:5432
- Redis: localhost:6379

## 다음 단계
1. docker-compose up -d 실행
2. http://localhost:3000 접속 확인
3. API 연동 테스트
"@

$report | Out-File "INTEGRATION_REPORT.md" -Encoding UTF8
Write-Host "`n📊 통합 보고서 생성 완료: INTEGRATION_REPORT.md" -ForegroundColor Green


 즉시 실행 필요 작업
Docker 환경 정리: 불필요한 docker-compose 파일 제거/백업
환경 변수 통합: .env 파일 하나로 통일
백엔드 Config 업데이트: Pydantic v2로 마이그레이션
프론트엔드 API 클라이언트: 통합 API 클라이언트 구현
테스트: 전체 시스템 연동 테스트

# 백엔드 엔드포인트 수집 (null/빈 문자열 체크 추가)
Get-ChildItem "cc-webapp/backend/app/routers" -Filter "*.py" -Recurse 2>$null | ForEach-Object {
    $content = Get-Content $_.FullName -Raw
    if (![string]::IsNullOrWhiteSpace($content)) {
        $matches = [regex]::Matches($content, '@router\.(get|post|put|delete|patch)\("([^"]+)"\)')
        foreach($match in $matches) {
            $backendEndpoints += $match.Groups[2].Value    
        }
    }
}

# 프론트엔드 API 호출 수집 (null/빈 문자열 체크 추가)
Get-ChildItem "cc-webapp/frontend" -Include "*.ts","*.tsx","*.js","*.jsx" -Recurse 2>$null | ForEach-Object {
    $content = Get-Content $_.FullName -Raw
    if (![string]::IsNullOrWhiteSpace($content)) {
        $matches = [regex]::Matches($content, '(fetch|apiClient\.|axios\.)(get|post|put|delete|patch)?\([\'"`]([^\'"`]+)[\'"`]')
        foreach($match in $matches) {
            $frontendAPICalls += $match.Groups[3].Value    
        }
    }
}


