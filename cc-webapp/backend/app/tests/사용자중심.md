사용자 중심 전역 플로우로 즉시 축 이동하겠습니다. 먼저 핵심 요구를 체크하고 단계별 실행 계획을 잡았습니다. 아래는 현재 새 우선순위와 바로 다음 액션 제안입니다.

요구 재정리 (전역 코어 플로우)

가입 / 인증 / 로그인 (온보딩)
메인 화면 (대시보드: 잔액, 진행중 이벤트, 오늘 보상)
이벤트 보상 받기 (reward claim)
이벤트 참여 (participate / progress)
게임하기 (게임 세션 시작/종료 기록)
프로필 확인 (레벨, 통계, 최근 활동)
상점에서 물건 구매 (일반 상점 + 재화 차감)
전역 데이터 서버 확장 (Kafka → ClickHouse / 분석 파이프 표준화)
프론트 전역 상태 (Auth + Profile + Events + Shop + Game state) 공유 구조
추가 고려

중복/불필요 사이드 기능(한정 패키지) → 유지하되 ‘코어 루프’ 밖으로 격리
이벤트/보상: 멱등(중복 수령 금지), 기간/조건 체크, 게임 플레이 연동
관측: Kafka 토픽 표준명 + 이벤트 스키마(고정 필드 + 확장 메타)
우선 착수 순서 (Fast Track) A. 현재 코드베이스에서 코어 라우트/스키마 존재 여부 스캔 → Gap 리스트
B. 이벤트 시스템 최소 스키마 & API 계약 초안 (participate, claim)
C. 전역 대시보드 응답 설계 (/api/dashboard) → 서버 집계 캐시 전략 포함
D. 프론트 전역 상태 모델(Store 구조) 설계 (auth + profile + dashboard + events + shop)
E. Kafka 이벤트 표준 Envelope 정의(event_type, user_id, ts, payload, trace_id)
F. 단계별 릴리즈 로드맵 문서화

다음 바로 진행할 작업 제안

(13) 전역 플로우 우선순위 재정의: 간단 메모 완성 (이미 개요 작성됨 → 완료 처리 가능)
(14) 백엔드 라우터 실제 목록 grep 해서 핵심 경로 존재/누락 확인
(15) 이벤트 시스템 설계 초안 파일 생성 (schema + API 계약)
(16) 프론트 전역 상태 다이어그램 (텍스트 구조로) 작성
(17) 데이터 파이프/Kafka 토픽 설계 문서
(18)(19) 로드맵 & 리스크 문서
확인 요청 (선택 하나 답변):

지금 바로 라우터 스캔 + Gap 분석부터 해라
이벤트 시스템 설계 초안 먼저 작성
대시보드(/api/dashboard) 통합 응답 계약부터
프론트 전역 상태(Store) 구조부터
숫자만 줘도 진행하겠습니다. 필요하면 “ALL”이라면 순서대로 빠르게 문서/파일 추가하며 진행할게요.



-----

전역 코어 사용자 여정(최소 성공 경로 MSC - Minimum Success Cycle)

가입(Signup) → 2) 로그인/JWT발급(Auth) → 3) 메인 대시보드 진입(Dashboard) → 4) 이벤트 목록 확인(Events List) → 5) 이벤트 참여(Participate) → 6) 게임 플레이 시작/종료(Game Session) → 7) 이벤트 조건 충족 후 보상 수령(Reward Claim) → 8) 프로필/진행도 확인(Profile) → 9) 상점 구매(Shop Purchase) → 대시보드 갱신(Loop Reinforcement)
각 단계 핵심 객체/데이터

User: id, site_id, nickname, tier, currencies (soft_currency, premium_currency), progression (level, exp, streak)
Event: id, type(daily/limited/progression), start_end_at, rules(condition JSON), reward_bundle
EventParticipation: user_id, event_id, progress (counters), status(active/claimable/claimed)
GameSession: session_id, user_id, game_type, started_at, ended_at, metrics(score, duration)
RewardGrant (idempotent): grant_id, user_id, source(event/game/manual), payload(json), granted_at
Purchase: purchase_id, user_id, sku_id, price, currency_type, granted_bundle, status(succeeded/failed)
Dashboard Aggregate(캐시): user snapshot + active events summary + pending rewards count
API (목표 통합 경로 제안) Auth:

POST /api/auth/signup
POST /api/auth/login
GET /api/auth/me
Dashboard:

GET /api/dashboard (원샷: profile + currencies + active_events + pending_rewards + recent_sessions(3) + shop_highlights)
Events:

GET /api/events (필터: active=true)
POST /api/events/{event_id}/participate
POST /api/events/{event_id}/progress (게임/행동 트리거 서버 내부에서 호출하거나 클라이언트 제한된 호출)
POST /api/events/{event_id}/claim
Game:

POST /api/game/sessions/start (body: game_type)
POST /api/game/sessions/{id}/end (score,duration,meta)
GET /api/game/sessions/recent?limit=10
Rewards (직접 조회/감사):

GET /api/rewards/pending
GET /api/rewards/history?limit=50
Shop:

GET /api/shop/catalog (정규 상품; 한정 패키지 별도 segmenting)
POST /api/shop/purchase (sku_id, quantity=1)
Profile:

GET /api/profile (상세: 누적 score / top_scores / 최근 이벤트 참여 상태 포함)
이벤트 상태머신 (간단) inactive -> active -> (progress < target) staying active -> claimable (조건 달성) -> claimed (종결)
만료 시: active|claimable -> expired (claim 불가)
멱등성: claim 시 reward_grant (unique grant_key=user_id+event_id) UPSERT

Kafka 이벤트 Envelope (표준) { "event_type": "user.signup" | "event.participate" | "event.progress" | "event.claim" | "game.session.start" | "game.session.end" | "shop.purchase.succeeded", "user_id": <int|null>, "ts": <iso8601>, "trace_id": <uuid>, "payload": { domain-specific }, "version": 1 }

ClickHouse 적재 (예시 테이블) CREATE TABLE events_log ( event_date Date, ts DateTime, event_type String, user_id UInt32, trace_id String, payload_json String ) ENGINE = MergeTree PARTITION BY toYYYYMM(event_date) ORDER BY (event_type, ts);

프론트 전역 상태(Store 슬라이스)

auth: { token, user, loading }
dashboard: { profile, currencies, eventsSummary, pendingRewardsCount, shopHighlights, lastFetched }
events: { list[], participationsById, claiming, errors }
game: { currentSession {id, game_type, started_at}, recent[], status }
shop: { catalog[], purchasingSku, purchaseResult }
rewards: { pending[], history[], loading }
ui: { toasts[], modal, networkBusy }
캐시/성능 전략

/api/dashboard 1초 내 재요청 시 ETag 혹은 If-None-Match 활용 (서버측 hash)
이벤트 진행(progress)은 서버 내부 (게임 세션 종료 Hook) 로 증가 -> 클라이언트 progress POST 최소화
reward claim 후 dashboard invalidate
즉시 후속 (다음 할 일 제안)

(14) 실제 코드 라우터 스캔하여 위 제안 대비 누락/중복 표 생성
(15) 이벤트 스키마 & Alembic 마이그레이션 초안 (events, event_participation, reward_grant)
(18) 단계별 릴리즈(Phase A: Dashboard read-only → B: Events participate → C: Game sessions → D: Reward claim/shop 통합)


-----

핵심 플로우 대비 현재 구현 vs 격차

Auth/Signup/Login: 이미 auth 라우터 존재 (세부 점검 후 토큰 회전/refresh 정책 명시 필요).
Dashboard: 세분화된 /api/dashboard/main|games|social-proof 만 존재 → 통합 /api/dashboard (핵심 KPIs + 진행 중 이벤트/미션 + 보상 요약) 신규 필요.
Events: /api/events/* (목록, 상세, join, progress, claim) 존재. 참여 중복 방지용 (user_id,event_id) 유니크 제약 없음 → 추가 권장. progress JSON 업데이트에 last_progress_at 없어서 레이스 타임스탬프 추가 권장.
Missions: /api/events/missions/* 세트 존재. daily/weekly reset 동작은 reset_at 컬럼(UserMission) 활용 가능. 진행/클레임 로직 idempotency 키 없음 → (user_id, mission_id, claimed) 유니크 + claim 시 user_rewards.idempotency_key 사용 권장.
Game Sessions: /api/games/session/start|end|active 구현. 이벤트/미션 자동 진행 반영 훅(진행량 증가 + Kafka publish) 미구현 → start/end/round 처리 후 mission/event progress service 호출 & kafka 이벤트 추가 필요.
Rewards: /api/rewards/distribute 중앙 분배 있음. 상점/한정패키지 구매는 별도 Reward + UserReward 직접 생성 → RewardService(distribute_reward) 호출로 통합 + idempotency_key = shop_tx.charge_id 또는 purchase:{tx_id}. 분배 이벤트 Kafka 존재(Rewards topic) → 이벤트/미션 claim 시도 동일 포맷 전송 필요.
Shop: 구매 흐름 안정. 한정패키지 compat endpoint 유지 중 → Phase B 이후 /limited/* 폐기 또는 /deprecated 네임스페이스 이동 계획 필요.
Profile: users / users_enhanced 라우터 존재 (세부 필드 합치기 및 /api/profile 단일 조회 정리 필요).
제안 스키마/마이그레이션 추가 (최소)

event_participations: UNIQUE (user_id, event_id), 인덱스 (user_id, completed, claimed_rewards).
event_participations: last_progress_at TIMESTAMP NULL.
user_missions: UNIQUE (user_id, mission_id), 인덱스 (user_id, completed, claimed).
user_missions: last_progress_at TIMESTAMP NULL.
user_rewards: (이미 idempotency_key unique + reward_type 인덱스 존재) → OK.
game_sessions: 이미 status, external_session_id 인덱스 있음 → OK.
새 뷰/머티리얼라이즈드? 선택: dashboard_aggregate 뷰 (user_id별 최근 24h 게임수, 미션 완료/진행, 미수령 보상 카운트) 후 Phase C 고려.
상태머신 요약

EventParticipation: CREATED(join) → IN_PROGRESS(progress 업데이트) → COMPLETED(progress 기준 충족) → CLAIMED(보상 지급).
UserMission: CREATED(자동 생성 또는 조회 시 lazy 생성) → IN_PROGRESS → COMPLETED(target_value 도달) → CLAIMED → (reset 주기 시) RESET_TO_CREATED.
Reward 분배: REQUESTED → (idempotency check) GRANTED(UserReward row 생성) → (optional use) CONSUMED.
API 계약 (추가/수정)

GET /api/dashboard: { kpis: {...}, active_events:[...], missions:{daily:[...], weekly:[...], achievements:[...]}, pending_rewards:int }
POST /api/events/{id}/progress (존재) → 응답에 server_progress_version / completed 플래그 포함(레이스 방지).
POST /api/events/{id}/claim: idempotency_key 허용(헤더 X-Idempotency-Key) → UserReward.idempotency_key.
POST /api/events/missions/{id}/progress, /claim (미션 전용 progress 엔드포인트 분리 고려) → 동일한 응답 구조 표준화 {status, progress, completed, claimed, reward_grant?:RewardItem}.
POST /api/rewards/distribute: 유지. 내부적으로 RewardService; shop/events/mission은 이 경로 호출로 통합.
Kafka 이벤트 표준 (value JSON) { "event_type":"reward.granted"|"event.progress"|"game.session.start"|"game.session.end", "user_id":..., "ts": ISO8601(Z), "trace_id": uuid, "payload":{ domain specific }, "idempotency_key": optional } 추가 토픽: gameplay_events (세션 start/end), mission_events, reward_events 통합 또는 단일 enrichment 파이프라인.

마이그레이션 파일 제안

versions/20250821_add_event_mission_progress_meta.py
add unique/indexes + last_progress_at columns.
안전: if exists/has_column 체크 guard.
Phase 제안(요약, 상세는 로드맵 Task 18에서)

Phase A: Unified /api/dashboard (읽기 전용 aggregation), progress/claim response 표준 스펙 정의 (코드 최소 수정).
Phase B: RewardService 통합(Shop/Events/Missions), unique constraints + idempotency enforcement, Kafka 이벤트 표준 적용.
Phase C: 자동 mission/event progress hook in game session start/end, analytics pipeline (Kafka → sink draft).
Phase D: Deprecated endpoints 정리, performance indexes 튜닝, dashboard materialized view/ caching.
즉시 구현 우선순위 (Phase A)

새 /api/dashboard 엔드포인트 추가 (기존 3개 내부 호출 or 서비스 레이어 통합).
이벤트/미션 claim 응답 형태 표준화 (progress_version + reward_items).
마이그레이션: unique 및 last_progress_at 컬럼.
리스크/주의

Unique 제약 추가 시 기존 중복 레코드 사전 정리 필요(스캔 후 삭제 또는 하나만 유지).
JSON progress 동시 업데이트 → lost update 방지: progress_version(int) 증분 or updated_at compare; 단순히 last_progress_at로 optimistic check 가능.
Idempotency 확장 시 기존 UserReward 중복 지급 케이스 회고 필요(최근 N일 스캔).
Dashboard aggregation 성능: 최초 간단 select + count; 후속 materialized view 고려.
다음 작업 제안 (Task 16~19 준비)

Task 16: 전역 상태 다이어그램 + store keys (auth.user, dashboard.summary, events.byId, missions.daily|weekly, rewards.pendingCount, game.activeSession).
Task 17: Kafka topic spec + ClickHouse 테이블 초안 (MergeTree by (event_type, ts, user_id) partition by toYYYYMMDD(ts)).
Task 18: 상세 Phase 문서화 + 테스트 영향도(새 claims tests, dashboard aggregator test).
Task 19: 리스크 표 + 대응 전략 (unique 추가 마이그레이션 롤백, idempotency race, Kafka outage fallback(로컬 WAL)).
필요 시 마이그레이션 초안 코드 생성 가능—진행할지 지시 주시면 즉시 작성합니다


------
Task 20 (Unified dashboard) 완료.
다음: Claim 응답 표준화(이벤트/미션), 모델 컬럼 & 마이그레이션, 서비스 progress_version 로직.
다음 제안 작업 순서

모델/마이그레이션 먼저: event_participations & user_missions 에 last_progress_at, progress_version(Integer, default 0), UNIQUE(user_id,event_id)/(user_id,mission_id).
서비스 로직: update_event_progress / update_mission_progress 에 progress_version +=1 & last_progress_at 갱신.
Claim 응답 스키마 수정: reward_items 배열 + progress_version 포함, idempotency 대비 (추후 UserReward 경로 통합 시).
테스트(추가):
새 /api/dashboard 200 & 필드 존재.
이벤트 progress 호출 시 progress_version 증가.
중복 join 후 unique 제약 위반 안됨.



업 완료 요약

모델 확장: event_participations, user_missions 에 progress_version, last_progress_at 컬럼 추가 (모델 + Alembic).
제약/인덱스: UNIQUE(user_id,event_id)/(user_id,mission_id) 및 조회 최적화 인덱스 추가 마이그레이션 작성.
서비스 로직: Event/Mission progress 업데이트 시 progress_version 증가 & last_progress_at 기록.
Claim 응답: ClaimRewardResponse 확장(progress_version, reward_items) + 이벤트 claim 라우터 적용.
통합 대시보드: /api/dashboard 추가(이전 완료 상태 유지).
다음 검증 권장(컨테이너 내부 실행)

alembic upgrade head (단일 head 유지 확인).
이벤트 진행/claim 수동 호출 → progress_version 증가 & claim 응답 reward_items 배열 노출.
동일 이벤트 재-join 시 UNIQUE 위반 없는지 (이미 존재하면 기존 participation 반환).
후속 남은 Task (16~19)

프론트 전역 상태/스토어 설계
Kafka/ClickHouse 이벤트 스트림 스펙
단계별 Phase 문서화
리스크/대응 표 작성


ions taken
Created four design/spec documents:
api docs/FRONT_STATE_MAPPING_SPEC.md
api docs/DATA_PIPELINE_SPEC.md
api docs/PHASE_ROADMAP.md
api docs/RISK_REGISTER.md
Each covers Tasks 16–19: frontend state map, data pipeline (Kafka→ClickHouse), phased roadmap (A–D), and risk register.
Updated todo list: Tasks 16–19 marked completed.
highlights
Frontend spec defines slices, caching, optimistic progress rules, progress_version handling, future SSE mapping.
Data pipeline spec standardizes event envelope, topic list, ClickHouse DDL (raw + MVs), outbox, dedupe, KPIs, rollout phases.
Roadmap details exit criteria per phase and testing strategy with rollback guidance.
Risk register catalogs technical, security, operational, product risks with mitigations and near-term actions.
next steps (optional)
Implement Mission claim response alignment (Phase B item).
Draft event_outbox migration + producer wrapper.
Prepare ClickHouse DDL execution scripts and basic health query.
Let me know if you want any of these converted into tasks/issues or expanded into implementation.


작업 요약
미션 클레임 응답을 이벤트와 동일한 표준 스키마로 정렬: progress_version, reward_items, new_balance 추가.
MissionService.claim_mission_rewards 수정: progress_version 증가, balance 포함 dict 반환.
ClaimRewardResponse 스키마에 new_balance 필드 추가.
events.py 미션 클레임 라우터 표준화 로직 적용(보상 dict → reward_items 배열 변환).
Outbox 마이그레이션 파일 생성: 20250821_add_event_outbox.py.
Outbox enqueue 유틸 생성: app/services/outbox_producer.py (트랜잭션 내 삽입용).
ClickHouse DDL 스크립트 추가: clickhouse_ddl.sql (raw 테이블 + 2개 MV).
Lint / 오류 검사: 수정된 파일들 에러 없음.
생성/수정 파일
event_schemas.py: new_balance 필드 추가.
events.py: 미션 claim 표준 응답 반환.
event_service.py: 표준 dict 반환 + progress_version 증가.
alembic/versions/20250821_add_event_outbox.py: outbox 테이블 생성 마이그레이션.
app/services/outbox_producer.py: outbox enqueue 함수.
clickhouse_ddl.sql: ClickHouse 테이블/MV DDL.


요청 요지: “프론트가 저(백엔드) 엔드포인트 그대로 쓰는 구조 맞나? 아닌 것 같다 → 프론트 파일 온보딩 학습/정리”.
아래에 프론트 실제 구조와 API 사용 패턴을 백엔드 엔드포인트와 비교·정리했습니다.

1. 전반 폴더 구조(요약)
app/ Next.js App Router 페이지들 (app/notifications, app/admin/... 등)
components/ 재사용 UI
hooks/ 커스텀 훅 (인증 토큰, 게임 API 클라이언트 등)
lib/ 경량 API helper 등 (simpleApi.ts)
utils/ 비교적 풀기능 API 래퍼 (api.ts, apiClient.js)
contexts/ 실시간/상태 컨텍스트 (RealtimeSyncContext.tsx 등)
public/devtools/ fetch 로깅 등 개발 도구 스크립트
types/ 타입 선언
scripts 빌드 ID 생성 등
openapi_spec.json, temp_openapi_live.json : 백엔드 스키마 스냅샷 (싱크 여부 확인 필요)
2. API 접근 레이어 3종
api.ts
고정 API_BASE_URL = 'http://127.0.0.1:8000'
토큰 로컬스토리지 직접(access_token/refresh_token)
401 시 refreshAccessToken() → /auth/refresh
엔드포인트들은 /auth/... (슬래시 앞에 /api 없음!)
simpleApi.ts
환경변수 NEXT_PUBLIC_API_BASE 우선
미설정 + 포트 3000이면 http://localhost:8000 fallback 경고
호출 시 경로 그대로 사용. 사용 예: /api/streak/status 처럼 백엔드 경로와 동일(백엔드는 /api/...)
useApiClient.ts
기본 base /api 로 시작 (상대경로) → 환경변수 NEXT_PUBLIC_API_URL 있으면 교체
joinUrl 로 중복 /api/api 방지
401 처리 시 내부 refresh 훅 사용 (useAuthToken)
=> 즉, “/api” 프리픽스를 빼고 쓰는 레이어(api.ts)와 붙여 쓰는 레이어(simpleApi.ts/useApiClient)가 혼재 → 온보딩 혼란/실패 가능.

3. 엔드포인트 prefix 불일치
백엔드 실제: 대부분 /api/auth/..., /api/streak/..., /api/gacha/..., /api/shop/... 프론트 일부:

api.ts auth 계열: /auth/login, /auth/register, /auth/me 등 ( /api 빠짐 )
refresh: /auth/refresh
health: /auth/health 다른 레이어:
simpleApi 사용 예 문서: /api/streak/status
useApiClient 기본 base /api → call('/streak/status') 형태라면 최종 /api/streak/status => 혼재로 인해 실제 호출 실패(404) 또는 CORS/프록시 종속 로직 필요.
4. 토큰 저장 방식 중복
api.ts: access_token / refresh_token 개별 키
useApiClient: cc_auth_tokens 번들(localStorage JSON)
simpleApi: 옵션으로 token 넘기거나, 별도 자동 로딩 없음 => 세 가지 포맷; 로그아웃/회전/동기화 시 일관성 문제.
5. 재시도/에러 처리 차이
simpleApi.ts: 지수백오프(retryOn 502/503/504/408/429) + 커스텀 delay
api.ts: 재시도 없음, 대신 401 refresh
useApiClient: 401 refresh 단 1회 재시도 => 공통 정책(보안/속도/사용자 메시지) 불균일.
6. 환경 변수 / 베이스 URL 전략 문제
현재 혼재:

고정 상수(127.0.0.1)
NEXT_PUBLIC_API_BASE
NEXT_PUBLIC_API_URL
암묵적 상대경로 (/api) 권장: 하나의 canonical: NEXT_PUBLIC_API_ORIGIN (예: http://localhost:8000) + 모든 호출은 join(API_ORIGIN, '/api/...').
7. 온보딩시 핵심 혼동 포인트
문제	영향	개선
/api prefix 혼재	404 또는 CORS	통합 래퍼에서 prefix 붙이기 강제
토큰 저장 키 3종	로그아웃/refresh 꼬임	단일 storage 모듈 + 인터페이스
retry 정책 다름	예측 어려움	중앙 retry 유틸 (옵션 주입)
Base URL 상수 고정	환경 전환 실패	단일 env + 필수 검증
Refresh 경로 상이 가능성	401 루프/실패	AUTH_PATHS enum 관리
중복 fetch 유틸	번들 크기 & 유지비	하나 유지, 나머지 deprecate 표시
8. 추천 통합 설계 (제안)
UnifiedApiClient (단일 모듈) 기능:

설정:
경로 인자: 'auth/login' → 최종 ${API_ROOT}/auth/login
옵션: {method, body, retry, auth: true}
토큰 스토리지: tokenStorage.get()/set()/clear() (단일 JSON {access_token, refresh_token, exp})
401 처리: refresh 함수 한 번, 실패 시 clear + 에러 throw
재시도: 공통 유틸 retryFetch(fn, {retries, backoff})
로깅: dev 환경에서만 그룹화 출력
타입:
마이그레이션 단계:

lib/unifiedApi.ts 새로 작성 (기존 영향 최소)
api.ts, simpleApi.ts, useApiClient.ts 상단에 Deprecation 주석 추가
주요 페이지/훅부터 교체 (auth → streak → shop 순)
테스트 (e2e + jest) 토큰 시나리오 업데이트
구 버전 제거
9. 단기 수정 우선순위
백엔드 실제 prefix 확인 (현재 /api/auth/register 사용) → 프론트 api.ts prefix 누락 부분 수정 또는 래퍼 교체
토큰 저장 스킴 통일 (cc_auth_tokens JSON 권장)
환경변수 표준 결정: .env 에 NEXT_PUBLIC_API_ORIGIN=http://localhost:8000
Deprecation 배너 (콘솔 warn) 넣어 중복 제거 진행 흔적 명확히
OpenAPI 동기화: openapi_spec.json 최신 export 후 Lint 도구로 DTO drift 감지
10. 온보딩용 요약(신규 팀원 전달)
API 호출은 unifiedApi.call('auth/login', {method:'POST', body:{...}, auth:false})
모든 엔드포인트 문자열은 /api/ 제외 (모듈이 자동 부착)
토큰은 tokenStorage (localStorage key: cc_auth_tokens)
401 자동 refresh 1회 → 실패 시 로그아웃
재시도: 네트워크/5xx(선정) 기반 최대 3회 지수백오프
환경변수: NEXT_PUBLIC_API_ORIGIN 필수, 없으면 콘솔 경고 + fallback
개발 로깅: dev 모드 console.group 로 요청/응답/에러
11. 다음 액션(원하면 바로 구현 가능)
새 unifiedApi.ts 생성 + 기존 파일 Deprecation 주석
authApi 를 새 래퍼 thin proxy 로 교체
토큰 스토리지 모듈화 (utils/tokenStorage.ts)
계속 진행하여 통합 코드 작성 원하면 “통합 구현 진행” 라고 지시해 주세요.
필요 시 특정 파일 더 열람/매핑 표 제작도 가능. 어떻게 이어갈지 말해줘.



Summarized conversation history

현재 프론트에 dashboard 관련 페이지 존재 여부를 정확히 파악해 새 페이지 필요성 판단을 위해 파일명에 'dashboard' 포함 여부를 검색합니다.

프론트 app 디렉토리에서 대시보드 페이지 후보를 찾기 위해 'dashboard' 문자열을 검색합니다.

프론트 components 디렉토리에서 HomeDashboard와 GameDashboard 컴포넌트 파일을 확인하기 위해 검색합니다.

GameDashboard 컴포넌트 파일 존재 확인을 위해 검색합니다.

핵심 판단 위해 HomeDashboard 컴포넌트 일부 내용을 읽어 현재 데이터 소스(API 호출 여부) 파악합니다.

Read HomeDashboard.tsx, lines 1 to 200

설명 지속 위해 GameDashboard 일부도 검사(파일 처음 200줄)해 API 호출 패턴 확인합니다.

Read GameDashboard.tsx, lines 1 to 160

현재 홈 루트 page.tsx 존재 여부 확인해 신규 페이지 필요성 판단을 보강합니다.

홈 page.tsx 상단 일부 읽어 현재 어떤 컴포넌트를 렌더하는지 확인합니다.

Read page.tsx

아니요, 지금까지 진행·정리된 ‘통합 /api/dashboard’, progress_version, claim 응답 표준화 같은 작업은 “백엔드 서비스/스키마/응답 구조 정렬” 중심이라서 새 “디자인 시안”이나 별도 “페이지(Route)”를 새로 만들 필요는 없습니다. 현재 폴더/컴포넌트 구조 기준으로 보면 다음과 같이 최소 변경만 하면 됩니다.

요점 정리

이미 루트 a[page.tsx](http://_vscodecontentref_/2) -> App.tsx 내부에서 HomeDashboard, GameDashboard 컴포넌트로 화면 전환을 하고 있으므로 추가 route (page.tsx 등) 생성은 필수 아님.
새 통합 데이터(프로필 + 이벤트 요약 + pending rewards + shop highlights 등)는 기존 HomeDashboard 가 여러 개 개별 API 호출(streakApi, apiGet('/api/vip/status') 등)로 조합하던 부분을 “단일 fetch”로 교체(또는 점진적 병합)하면 됨.
디자인 재작성 필요 없음: 현 UI 레이아웃을 유지한 채 데이터 소스만 통합 엔드포인트로 스위칭 → 로딩/에러/부분적 fallback 로직만 추가.
추가로 필요한 것은 “상태/캐시 훅” 한 개 (예: hooks/useDashboard.ts) 또는 기존 useEvents, useAuthGate와 유사한 패턴으로 통합 응답을 가져오는 훅. 이것도 UI 페이지가 아니라 재사용 로직 파일.
전역 Store(아직 미구현) 도입 전이라면 임시로 HomeDashboard 내부 useEffect 하나를 “/api/dashboard” 호출로 교체 후 기존 개별 호출 일부 제거 → 추후 Store 설계(Task 16 결과) 반영 시 리팩터링.
구체적 변경 최소 세트 (프론트)

새 페이지: 불필요.
새 디자인: 불필요.
새 파일(선택): frontend/hooks/useDashboard.ts (캐시 + stale 시간 1초 내 재요청 skip).
기존 HomeDashboard.tsx:
여러 개 개별 API 호출 묶음을 /api/dashboard 1회 호출로 선행(점진: 먼저 통합 호출 추가 후 성공 시 부분 필드 매핑 → 단계적으로 옛 호출 제거).
응답 구조: { profile, active_events, pending_rewards, shop_highlights, recent_sessions } 등 → 이미 갖고 있던 state들에 매핑.
에러/로딩 핸들링: 지금 있는 콘솔 디버그 수준이면 충분, 후속으로 skeleton 적용 가능(선택).
백엔드 측 이미 완료/진행 중 사항 영향

Claim 응답 표준화(new reward_items, progress_version) 반영 시 프론트에서 개별 이벤트/미션 클레임 후 state invalidation 로직만 조정(기존 여러 엔드포인트 기존 필드명 바뀌었으면 타입 업데이트).
Unique 제약, progress_version 은 프론트 디자인 영향 없음 (단, optimistic UI 시 progress_version 충돌 검사 추가 가능).
언제 새 페이지가 필요해질까? (옵션)

관리자용 종합 KPI 대시보드 (운영지표) 추가 시: page.tsx 등.
사용자용 세부 “활동 로그”/“리워드 히스토리” 별도 뷰 분리 필요 시. → 현재 MSC(최소 성공 사이클) 범위에는 비필수.
추천 다음 액션 (선택) A. 훅 useDashboard 초안 생성 → HomeDashboard 교체 B. 기존 다중 호출 제거 (streak 제외 점진) C. Claim 후 invalidateDashboard() 호출 방식(훅 내부 timestamp 갱신) 추가

요청하시면 바로 A~C 구현 패치 넣을 수 있습니다. “통합 대시 훅 구현” 같이 한 단어 지시 주면 진행하겠습니다.


------

즉시(Phase A 마무리) – 안전한 전환 기반
(1) Phase A 잔여 정리: 프론트 useDashboard 완전 교체 후 기존 다중 호출 제거 → /api/dashboard 응답 필드 스냅샷을 테스트 픽스처로 캡쳐(스키마 드리프트 감지).
(2)+(3) 유니크/마이그레이션: UNIQUE 추가 전 사전 스캔 쿼리 SELECT user_id,event_id,COUNT() c FROM event_participations GROUP BY 1,2 HAVING COUNT()>1; 중복 있으면 가장 최신(progress 최대 혹은 created_at 최신) 1건 남기고 나머지 삭제 스크립트 → 로그 파일 남김. Alembic 적용 직후 heads 단일성 검사 → api docs/20250808.md “변경 요약/검증/다음 단계” 블록 추가.
(5) Claim 통합 테스트: pytest에서
participate → progress → claim
동일 claim 재시도 (Idempotent) → reward_items 동일 / progress_version 불변
race: 두 번 거의 동시에 claim → 한쪽만 성공 assert (HTTP 200 / 409 or 동일 payload)
(6) Fetch/토큰 통합: unifiedApi.ts + tokenStorage.ts 추가, legacy 래퍼 첫 줄 console.warn(‘DEPRECATED…’). 점진 교체: auth → dashboard → claim → shop 순.
데이터 정합 & 보상 멱등 (Phase B Core)
(4) RewardService 통합: Contract: grant_reward(user_id, reason, bundle, idempotency_key) → {applied: bool, new_balances, reward_items} 인덱스: user_rewards(idempotency_key) UNIQUE 이미 활용. 이벤트/미션/상점 모두 이 경로 호출. 실패 케이스: Duplicate → applied=false, HTTP 200 + idempotent.
(7) 게임 세션 Hook: session_end → 내부 트랜잭션: update progress tables, enqueue_outbox(event_type='game.session.end', payload{...}, trace_id) 주의: 실패 시 세션 종료 롤백 → 재시도 가능성 대비 idempotency (session_id unique).
(8) Outbox Processor: 스케줄러(매 2초) SELECT * FROM outbox WHERE status='pending' AND next_attempt_at <= now() ORDER BY id LIMIT 100 FOR UPDATE SKIP LOCKED Kafka publish 성공 → status='sent', sent_at 실패 → attempt_count++, backoff (min(2^attempt, 300s)), dead-letter 기준 attempt>=10 Dead-letter 테이블 outbox_dead_letters (원문 payload + last_error)
(10) 관측 지표: Metrics 노출 (Prometheus endpoint): dashboard_response_ms (histogram) reward_claim_duration_ms outbox_pending_count / outbox_lag_seconds (now - created_at 평균) kafka_publish_failures_total Alert 기준 초안: outbox_lag_seconds p95 > 30s 5분 지속 → 경고.
성능 & 확장 (Phase B 후반 → C 초입)
(14) 대시보드 캐시: 서버: Redis key dashboard:{user_id} JSON + ttl 5s ETag: hash(json) → If-None-Match 처리 304 Invalidation: reward claim / purchase / mission progress completion에서 delete key 테스트: 첫 요청 200 ms 측정, 연속 요청 304 혹은 캐시 15–30ms 이하 목표.
(15) 프론트 Store: 슬라이스별 invalidate 규칙 명시(예: claim 성공 → dashboard & events & rewards pending invalidate). Store 도입 전 커스텀 훅 레벨에서 TTL + SWR 패턴 유지 가능.
(9) ClickHouse 초기 적재:
Outbox → Kafka → Connector(or lightweight consumer) → ClickHouse INSERT (batch 1s/5k rows)
헬스 스크립트: 최근 5분 이벤트 count, ingestion delay (max(ts_ingested - ts_event)) 목표: ingestion delay < 3s p95.
품질/안전 자동화
(11) 부하 테스트: k6 script: signup→login→dashboard→participate→(loop progress)→claim→purchase 95th latency 목표: dashboard <150ms, claim <200ms, purchase <250ms 임계 초과 시 flamegraph(py-spy) + SQL EXPLAIN 분석.
(12) 보안 하드닝: 로그인 rate limit Redis (key ip:login per 5m) claim rate limit (user:claim per 10s) → HTTP 429 or graceful 200 {accepted:false} 관리자 감사 로그: 모든 reward_grant(applied) & UNIQUE 충돌 처리 기록.
(13) 무결성 감사 크론:
음수 잔액 SELECT id FROM users WHERE gold_balance < 0
중복 reward idempotency SELECT idempotency_key, COUNT(*)>1
비정상 gold ( > 기본*100 ) outlier 결과 json 저장 + Slack/Webhook (추후)
회귀/문서/릴리즈
(16) 핵심 사이클 End-to-End pytest + (선택) Playwright front smoke
(18) release_check.ps1: Steps: pytest -q → alembic heads (1) → curl /health → export openapi → diff 이전 스냅샷 → summarize risks
(19) 플레이북: UNIQUE 충돌 롤백: alembic downgrade + 중복정리 재시도 Kafka 다운: outbox processor skip publish, lag 증가 모니터링, 재기동 후 catch-up ClickHouse 지연: fallback 분석(직접 Postgres events table 임시 조회)
(20) Phase B 종료 KPI 수집 스크립트 (Prometheus API → json → report)
실행 순서 제안(배치) Batch 1 (안전 기반): 2→ 중복 스캔, 3→ 마이그레이션 적용, 1→ 프론트 훅 교체, 5→ claim 테스트 Batch 2 (보상/멱등): 4→ RewardService 통합, 6→ Fetch 통합, 14→ 캐시 Batch 3 (게임/이벤트/스트림): 7→ 세션 Hook, 8→ Outbox Processor, 10→ Metrics Batch 4 (확장/분석): 9→ ClickHouse, 11→ 부하, 13→ 무결성, 12→ 보안 Batch 5 (자동화/평가): 15→ Store, 16→ 회귀, 18→ 릴리즈 스크립트, 19→ 플레이북, 20→ KPI 평가, 17→ Deprecated 정리

리스크 및 완화 요약

UNIQUE 적용 중 중복 → 사전 스캔/정리 스크립트로 제로 다운 적용.
Outbox 폭주 → SELECT ... SKIP LOCKED + 배치 크기 제한 + dead-letter.
캐시 일관성 → invalidate 트리거 집중(Reward, Purchase, Progress complete).
재시도 루프(토큰/claim) → idempotency_key + attempt cap.
Kafka 불가 → fallback 로그(파일/DB) + 재전송 태스크.
측정 기준(관측 목표)

outbox_pending_count < 500 지속
outbox_lag_seconds p95 < 30
dashboard_response_ms p95 < 150
reward_claim_duration_ms p95 < 200
claim idempotent 재시도 성공률 100% (중복 지급 0)
UNIQUE 위반 런타임 에러 0 (사전 정리 후)
필요 산출물(차후 생성 권장)

scripts/scan_duplicates.py (이벤트/미션 중복 리포트)
scripts/release_check.ps1
backend/app/services/reward_service.py (단일 진입)
backend/app/workers/outbox_processor.py (주기 실행)
prometheus_metrics.py (등록 함수)
tests/test_claim_idempotency.py, tests/test_dashboard_cache.py, tests/test_outbox_processor.py
docs/OUTBOX_PIPELINE.md, docs/DASHBOARD_CACHE.md, docs/RELEASE_CHECKLIST.md
다음 바로 수행할 1개 선택 지시 주세요: A) 중복 스캔 쿼리/스크립트부터 B) RewardService 통합 코드 초안 C) 대시보드 훅 프론트 교체 패치 D) Outbox Processor 기본 뼈대 E) 릴리즈 체크 스크립트 초안


